[{"title":"Quando você precisa parar","description":"\"As vezes queremos sempre ser produtivos mas, não precisamos\"","tags":[],"slug":"quando-voce-precisa-parar","html":"Eu atrasei meu retorno ao trabalho e isso foi ótimo! Recentemente tirei férias, deixei o canal e outras atividades um pouco de lado que é algo que recomendo que todo mundo faça. Quando voltei, fui informado de que precisava ficar fora do apartamento por uma semana. Por mais que fossem férias, confesso que foram meio estressantes, porém tudo bem, às vezes uma viagem de férias não sai como esperamos. Além disso, quando você quer voltar pra sua casa e não consegue, também é ruim. Quando voltamos pra casa tinha aquela lista interminável de coisas pra fazer: uma fila de vídeos pra subir no canal, trabalho no Capicart e no Keyrunes pendentes, além de continuar trabalhando no curso de Rust. Além é claro de algumas obirgações legais e cuidados com a casa em si. Mas aí aconteceu algo... Bom, se você não sabe, eu estudo alemão hoje. Acabou a fase do B1, que é uma parte do curso de integração que precisava fazer por morar aqui. Agora vou pra segunda fase, que é chegar até o nível B2. Contúdo, muitos dos meus colegas de curso não vão continuar, seja porque não conseguiram passar na prova ou porque, nesse momento, vão optar por pegar algum trabalho e continuar os estudos no futuro. Com isso, eu decidi conversar no particular com alguns deles, e essa foi uma das melhores coisas que fiz nos últimos tempos. Primeiro, porque durante o curso eu evitava falar com eles fora do curso por achar que poderia ser uma pessoa desagradável. Além disso, por ser o único brasileiro, não conheço bem a cultura dos meus colegas e não sei como eles se sentem sendo abordados diretamente. E por que foi bom? Primeiro, porque muitos deles me consideravam uma pessoa educada, gentil e prestativa. Algo que não imaginava que eu era, muito porque, na minha visão particular, acho que tenho cara de pessoa que está entediada com tudo que está sendo dito. E, dado algumas situações, isso acabou me trazendo um ânimo. Às vezes vem alguém me agradecer por algum vídeo no YouTube, o que sempre é bacana, mas não é muito comum até pelo canal ser pequeno. Isso acabou dando uma injeção de ânimo. Outro ponto é parar pra ouvir a história de outras pessoas: o que as fez vir pra Alemanha e o que elas pensam do futuro. Isso é um exercício que eu fazia muito quando tutorava desenvolvedores mais jovens onde eu trabalhei, e acredito que é algo muito enriquecedor tanto pra mim quanto pra pessoa que está dividindo sua história. Além disso, pude compartilhar algumas histórias com algumas pessoas. O fato de ter alguém pra conversar e falar de seus anseios, problemas e felicidades, pra mim, é algo que acabou trazendo um novo ânimo. Também me faz pensar nas minhas próprias escolhas, tanto na vida pessoal quanto profissional. Tanto que, quando voltei a refletir nos meus trabalhos e no meu dia a dia, repensei algumas coisas que estava fazendo e agora estou tentando fazer de uma forma diferente. Acredito que, às vezes, poder compartilhar um pouco e receber também de outras pessoas é algo ótimo pra ajudar o próximo, além de também trazer uma visão diferente do que você está fazendo. Já passamos da metade do ano, e essas conversas, pra mim, me ajudam quando preciso organizar as coisas: verificar projetos que precisam continuar, parar ou mudar, ou até um hábito que gostaria de incluir ou abandonar. Pois trazem um frescor pro meu dia a dia. Muitas vezes nós estamos apenas fechados nos nossos problemas, desafios e vícios. Eu sou uma pessoa introvertida e tímida. Muitas vezes tenho dificuldade até de conversar com outras pessoas. Provavelmente precise fazer um teste pra verificar se não estou dentro do espectro do autismo, mas, mesmo assim, compartilhar experiências com outras pessoas é algo que me ajuda como uma renovação da minha energia. Além disso, muitas vezes consigo ajudar a pessoa de alguma forma. É a famosa relação ganha-ganha, e fico muito feliz quando alguém consegue melhorar a sua vida de alguma forma e eu ajudei com alguma palavra amiga ou de motivação. Sinto que fui um agente de mudança para o bem. Por isso, a reflexão que gostaria de trazer hoje é: você tem falado com amigos ou parentes? Tem compartilhado histórias que vão além de novos projetos, coisas do trabalho, coisas pra estudar etc.?"},{"title":"Aprendendo Rust em 2025 e seus mitos","description":"\"Aprendendo Rust do zero - Removendo mitos e ajudando a começar\"","tags":[],"slug":"aprendendo-rust-em-2025-e-seus-mitos","html":"Veja também em vídeo Bom nesse breve texto quero falar um pouco sobre como aprender rust, além de tirar alguns mitos. Rust é uma linguagem muito legal, uso ela em alguns projetos além de usar ela no jogo que estou desenvolvendo, hoje falando com algumas pessoas percebo alguns obstáculos que se coloca para aprender rust e gostaria de ajudar a clarear um pouco. Mitos: Aprender C/C++: Além de que se você souber a linguagem seja algo que te ajude, não é algo mandatório para aprender Rust, tem muita gente na comunidade que tem esse background. **Saber estrutura de dados e algortimos: **Também é um conhecimento importante pra se tornar um programador melhor, porém não é mandatório. **Saber design partterns: **Esse eu vejo as pessoas muito obsecadas pelo livro da Gang of 4 mas, sinceramente é algo que você deve estudar depois de já ter certo conhecimento em qualquer linguagem, além de que algumas linguagens resolvem os patterns de outras formas. Aprender ponteiros: Como disse tem pessoas de outros backgrounds, e conforme você aprende Rust você vai identificando como a mémoria é alocada e suas referências e isso pode até te levar aprender como funcionam os ponteiros em c/C++ por exemplo, mas não é mandatório. Aprender Rust por que não quer aprender ponteiros: como disse tem pessoas na comunidade com background em C/C++ e que continuam trabalhando nessas linguagens, inclusive usam-se Rust hoje no desenvolvimento do kernel Linux, não vejo essas pessoas que trabalham lá usando Rust por que simplesmente não querem aprender ponteiros. Então nada disso é importante? Como falei coisas que citei anteriormente podem ser importantes para se tornar um programador melhor (como algorimo e estrutura de dados), porém se você está aprendendo a linguagem não é mandatório, com o tempo você vai incluindo isso no seu plano de estudos. Bom tirando os mitos como você pode aprender rust? Vou dar algumas dicas para você começar a estudar. Pra quem está iniciando: Pensando em mercado de trabalho é interessante conhecer outra linguagem, e disso isso não por que o Rust é dificil, mas por que pensando em trabalhar com a linguagem, normalmente vão pedir que você tenha conhecimento em outra linguagem. Conhecimento gradual: Penso que assim como no vim o Rust (e na real qualquer outra linguagem) você precisa de consistência, não adianta estudar 40 horas uma semana e depois ficar 1 mês sem estudar. O importante mesmo que seja pouco tempo que seja constante, assim você vai conseguindo aprender de forma graudal. Então como aprender ? Restringindo o material: Como sempre falo, não adianta comprar 10 livros e 5 cursos se você está inciando na linguagem, isso vai mais atrapalhar que ajudar, a principio use apenas um material e com o tempo conforme já vai tendo conhecimento aumente o seu conteúdo. Aqui algumas sugestões de materiais gratuitos pra começar: Documentação do Rust https://rust.sh https://livro.rustbr.org/ - Pt_Bt Praticar - não adianta só ler Não leia um livro técnico como um romance e nem assista um curso como netflix, sempre tente refazer os exemplos e fazer exercícios do tópico que está aprendendo com isso você vai conseguir fixar os conceitos. Onde posso praticar em qualquer lugar? Rust playground pra mim é uma ótima ferramenta pra quem ta começando pois você pode usar seja no computador quanto no celular. http://play.rust-lang.org/ Como me preparar para estudar? Tempo e ambiente pra estudos: Defina um tempo na sua semana (ela pode variar durante a semana) e foque em estudar, tenha um ambiente onde você consiga definir como local de estudo, se tem barulho tente um fone para rudizir ruidos, se muito silêncio te atrapalha tente ruido branco, procure apenas deixar o ambiente proprio para focar. Um computador: Além de acreditar que da pra fazer muitas coisas com o celular, mas em algum momento você vai precisar de um computador, e pode ser um computador antigo o importante na minha visão é ser pelo menos com um processador de 64bits e ter pelo menos uns 2Gb de memória. Linux, Mas ou Windows?: Sinceramente pra mim é uma questão de gosto o Rust roda em todos esses sistemas, só diria que se seu computador for antigo e sem muitos recursos o linux funcionaria melhor com uma distribuição mais focada nesse nicho. Instalar linguagem: Linux e Mac da pra insalar usando o script da página da linguagem e com o windows você vai precisar usar algo como chocolately ou wsl2. Faça Exercícios: Isso é muito importante sempre pratique o que está aprendendo e se precisar de uma dica de site sempre recomendo o exercism Expandindo material: Você já conseguiu um conhecimento básico da linguagem? Já consegue fazer pequenos projeto? Então pode tentar buscar novos livros e cursos para aprofundar em algum tópico. O que eu recomendo Livros: Hands on Rust - Inglês Programming Rust - Inglês Rust: Concorrência e alta performance com segurança Programação Funcional e Concorrente em Rust Curso Meu curso de rust Ultimate Rust Crash Course - Inglês Caso tenha gostado do artigo eu elaboro um pouco mais ele no meu vídeo não deixe de dar uma conferida. https://youtu.be/STMPnPRrv8k"},{"title":"Como melhorar suas queries no SQLAlchemy com column_property","description":"\"Como melhorar suas queries no SQLAlchemy usando column_property.\"","tags":[],"slug":"como-melhorar-suas-queries-no-sqlalchemy-com-column-property","html":"Bom hoje quero falar com vocês uma coisa que fiz recentemente para facilitar algumas coisas no meu e-commerce open source. Para entender o cenário eu tenho as tabelas a ProductDB, InventoryDB e CategoryDB onde: CategoryDB tem as categorias onde um produto só pode ter uma categoria InventoryDB é onde fica registrado o estoque num formato de &quot;extrato&quot; onde pode ser adicionado ou removido estoque de um produto. Um produto pode ter várias entradas em InventoryDB seja de entrada ou saída. Então para criar uma query onde eu preciso retornar uma lista de produtos com sua categoria e a quantidade pode ser algo não muito trivial se você quiser tentar resolver tudo isso na query como abaixo: with (db): category_alias = aliased(CategoryDB) products = ( select( ProductDB.product_id, ProductDB.name, ProductDB.uri, ProductDB.price, ProductDB.active, ProductDB.direct_sales, ProductDB.description, ProductDB.image_path, ProductDB.installments_config, ProductDB.installments_list, ProductDB.discount, ProductDB.category_id, ProductDB.showcase, ProductDB.feature, ProductDB.show_discount, ProductDB.height, ProductDB.width, ProductDB.weight, ProductDB.length, ProductDB.diameter, ProductDB.sku, ProductDB.currency, func.coalesce(func.sum(InventoryDB.quantity), 0).label( 'quantity', ), category_alias.category_id.label('category_id_1'), category_alias.name.label('name_1'), category_alias.path, category_alias.menu, category_alias.showcase.label('showcase_1'), category_alias.image_path.label('image_path_1'), ) .where( ProductDB.name.ilike(f'%{search}%'), ) .outerjoin( InventoryDB, InventoryDB.product_id == ProductDB.product_id, ) .join( category_alias, ProductDB.category_id == category_alias.category_id, ) .group_by(ProductDB.product_id, category_alias.category_id) ) products = db.execute(products) products_list = [] keys = products.keys() for product in products: product_dict = dict(zip(keys, product)) if 'category_id_1' in product_dict: product_dict['category'] = { 'category_id': product_dict['category_id_1'], 'name': product_dict['name_1'], 'path': product_dict['path'], 'menu': product_dict['menu'], 'showcase': product_dict['showcase_1'], 'image_path': product_dict['image_path_1'], } del product_dict['category_id_1'] del product_dict['name_1'] del product_dict['path'] del product_dict['menu'] del product_dict['showcase_1'] del product_dict['image_path_1'] products_list.append(ProductCategoryInDB.model_validate(product_dict)) Veja que uso o pydantic como modelo para retornar para minha API e nesse formato tenho alguns problemas. Eu preciso passar minha categoria pois, nos meus testes locais aqui ele não retornava as colunas de column mesmo que ele estivesse mapeado o relacionamento na minha tabela: class ProductDB(Base): __tablename__ = 'product' product_id: Mapped[int] = mapped_column(primary_key=True) name: Mapped[str] uri: Mapped[str] price: Mapped[Decimal] active: Mapped[bool] = mapped_column(default=False) direct_sales: Mapped[bool] = mapped_column(default=False) description: Mapped[Json] = mapped_column(JSON, nullable=True) image_path: Mapped[str | None] installments_config: Mapped[int] installments_list: Mapped[dict] = mapped_column(JSON, nullable=True) discount: Mapped[int | None] category_id: Mapped[int] = mapped_column( ForeignKey('category.category_id'), ) category: Mapped['CategoryDB'] = relationship( foreign_keys=[category_id], backref='ProductDB', cascade='all,delete', uselist=False, lazy='joined', ) inventory = relationship( 'InventoryDB', backref=backref('ProductDB', uselist=False), cascade='all,delete', foreign_keys=[product_id], primaryjoin='ProductDB.product_id == InventoryDB.product_id', ) showcase: Mapped[bool] = mapped_column(default=False) feature: Mapped[bool] = mapped_column(default=False, server_default='0') show_discount: Mapped[bool] = mapped_column(default=False) height: Mapped[Decimal | None] width: Mapped[Decimal | None] weight: Mapped[Decimal | None] length: Mapped[Decimal | None] diameter: Mapped[Decimal | None] sku: Mapped[str] currency: Mapped[str] = mapped_column(default='BRL') Então por que isso acontece? Se eu tentar executar minha query usando algo como db.scalars.all() como o objeto não está mapeando da model ele me voltar uma tupla, com isso preciso pegar essa tupla e fazer o mapeamento na mão da tabela category e além disso eu tenho o trecho abaixo para calcular a quantidade. func.coalesce(func.sum(InventoryDB.quantity), 0).label( 'quantity', ), E justamente esse campo calculado me impedia de mapear usando db.scalars().all() que me ajudaria a montar mais facilmente o objeto no pydantic usando um adapter. Olhando pra isso acreditava que teria uma forma mais facil de resolver isso e ela existe que é a column_property. column_property é uma maneira de definir atributos em seus modelos que são calculados a partir de expressões SQL, em vez de serem armazenados diretamente no banco de dados. Pense neles como &quot;colunas virtuais&quot; que existem apenas quando você consulta seu modelo. Falando de forma mais simplista, eu consigo criar um campo calculado direto na minha model como fosse a função de soma e como está na model eu consigo criar um objeto do ORM que facilita a conversão pro modelo do pydantic. A model ficaria assim: class ProductDB(Base): __tablename__ = 'product' product_id: Mapped[int] = mapped_column(primary_key=True) name: Mapped[str] uri: Mapped[str] price: Mapped[Decimal] active: Mapped[bool] = mapped_column(default=False) direct_sales: Mapped[bool] = mapped_column(default=False) description: Mapped[Json] = mapped_column(JSON, nullable=True) image_path: Mapped[str | None] installments_config: Mapped[int] installments_list: Mapped[dict] = mapped_column(JSON, nullable=True) discount: Mapped[int | None] category_id: Mapped[int] = mapped_column( ForeignKey('category.category_id'), ) category: Mapped['CategoryDB'] = relationship( foreign_keys=[category_id], backref='products', cascade='all,delete', uselist=False, lazy='joined', ) inventory = relationship(&quot;InventoryDB&quot;, back_populates=&quot;product&quot;) showcase: Mapped[bool] = mapped_column(default=False) feature: Mapped[bool] = mapped_column(default=False, server_default='0') show_discount: Mapped[bool] = mapped_column(default=False) height: Mapped[Decimal | None] width: Mapped[Decimal | None] weight: Mapped[Decimal | None] length: Mapped[Decimal | None] diameter: Mapped[Decimal | None] sku: Mapped[str] currency: Mapped[str] = mapped_column(default='BRL') quantity = column_property( select(func.coalesce(func.sum(InventoryDB.quantity), 0)) .where(InventoryDB.product_id == product_id) .correlate_except(InventoryDB) .scalar_subquery(), ) Ai crio um novo atributo como column property e faço uma query dentro dele com a soma. Assim consigo simplificar a minha query para ficar assim: async with db().begin() as transaction: products = ( select(ProductDB) .where(ProductDB.active == True) .order_by(ProductDB.product_id.asc()) ) result = await transaction.session.execute(products) adapter = TypeAdapter(List[ProductCategoryInDB]) products_list = result.scalars().all() products_list = adapter.validate_python(products_list) Ai uso um TypeAdapter já com o tipo de retorno que preciso e retiro aquele loop para montar o objeto na mão e tenho tudo já retornando automagicamente. Assim quantity é uma coluna lazy ou seja cada vez que for chamar quantity no meu objeto products_list ele vai rodar uma subquery. Esse é o preço que vou pagar aqui, pois ao invés de já calcular esse campo diretamente na minha query principal e só acessar quantity toda vez que chamar a coluna de alguma dessas linhas ele vai rodar a query da quantidade. Num cenário com muitas linhas isso pode criar um gargalo, porém como a versão real dessa query eu uso paginação é um ônus pequeno e que vai cair principalmente no banco de dados mas, não creio que vá deteriorar meu banco e em contra-partida eu consigo ter uma query mais simples e evito laços direamente em python e uso todo o poder do pydantic. Bom espero que isso te ajude nos seus desafio com SQLAlchemy e Pydantic!"},{"title":"Deploy flask application with subdomain on Heroku","description":"\"As ferramentas que estou usando no meu workflow de trabalho\"","tags":[],"slug":"deploy-flask-application-with-subdomain-on-heroku","html":"Hello, I made a very detailed guide on how I uploaded an example project using Heroku and Cloudflare, I hope I can help you. As a first step, let's create our project folder: mkdir flask_example In this example, we are going to use poetry to manage dependencies and for that, we need to install it via pip. pip install poetry Let's do the poetry init command to start our configuration, in this case, let's just follow its default configuration, as below: ❯ poetry init This command will guide you through creating your pyproject.toml config. Package name [flask_example]: Version [0.1.0]: Description []: Author [Jonatas Oliveira &lt;contact@jonatasoliveira.dev&gt;, n to skip]: License []: Compatible Python versions [^3.13]: Would you like to define your main dependencies interactively? (yes/no) [yes] You can specify a package in the following forms: - A single name (requests): this will search for matches on PyPI - A name and a constraint (requests@^2.23.0) - A git url (git+https://github.com/python-poetry/poetry.git) - A git url with a revision (git+https://github.com/python-poetry/poetry.git#develop) - A file path (../my-package/my-package.whl) - A directory (../my-package/) - A url (https://example.com/packages/my-package-0.1.0.tar.gz) Package to add or search for (leave blank to skip): Would you like to define your development dependencies interactively? (yes/no) [yes] Package to add or search for (leave blank to skip): Generated file [tool.poetry] name = &quot;flask-example&quot; version = &quot;0.1.0&quot; description = &quot;&quot; authors = [&quot;Jonatas Oliveira &lt;contact@jonatasoliveira.dev&gt;&quot;] readme = &quot;README.md&quot; packages = [{include = &quot;flask_example&quot;}] [tool.poetry.dependencies] python = &quot;^3.13&quot; [build-system] requires = [&quot;poetry-core&quot;] build-backend = &quot;poetry.core.masonry.api&quot; Now let's install the minimal packages for this example. poetry add flask python-decouple python-dotenv gunicorn Now we create the default directories for static and templates, this example we not use, but is good use with reference. mkdir static template Now let's create the default directories for static and template, in this example, we won't use them, it's more to use as a reference. touch config.py app.py main.py Now let's enter the shell and create the main.py file. import locale from flask import Flask import config as default_config def create_app(config=None) -&gt; Flask: locale.setlocale(locale.LC_ALL, &quot;pt_BR.UTF-8&quot;) # set locale app = Flask(__name__, static_folder=&quot;../static&quot;, template_folder=&quot;../templates&quot;) if config is None: config = default_config app.config.from_object(config) return app Here I'm already using the flask's config template in a separate file, which isn't the simplest way to get started but is best for a project that expects to grow. def create_app(config=None) -&gt; Flask: Here we define our create_app function which is basically our app flask initialization function. app = Flask(__name__, static_folder=&quot;../static&quot;, template_folder=&quot;../templates&quot;) Here I set the flask app and define the static_folder and the template_folder, in the API projects these settings can be optional. if config is None: config = default_config app.config.from_object(config) Here we configure the import of the config for the project, we could set the config directly in create_app but it is more organized to use a file just for organization. As a parameter of create_app, we put config, in this case, it is set to none by default, this is especially important for testing, where we can configure an exclusive config for testing or if we want to separate the production config. So when calling the app we can pass the config we want. return app Finally, we return the app we want. For now, nothing works, but let's now create our default route using a blueprint. Let's create the root_blueprint.py file, from flask import Blueprint main_blueprint = Blueprint('Main Blueprint with root domain', __name__) @main_blueprint.route('/') def index(): return &quot;This is a main blueprint&quot; where: from flask import Blueprint main_blueprint = Blueprint('Root route', __name__) Here we import the Blueprint and define it as a description. @main_blueprint.route('/') def index(): return &quot;This is a main blueprint&quot; Here we create our default route in &quot;/&quot; which is the root of the project. Now let's register our blueprint in main.py # Blueprints and API Namespaces from root_blueprint import main_blueprint app.register_blueprint(main_blueprint) Let's create the app.py file so we can start our flask application using it. from main import create_app app = create_app() Now let's run our application by first starting the venv with poetry then let's set it to start in debug mode and run the flask. poetry shell export FLASK_DEBUG true flask run Run with localhost and see the message below appear: Now let's configure the subdomain in the local environment. Go to /etc/hosts and configure our domain and subdomain, it is important to try to use a non-valid domain on the internet because if, for example, you use google.com instead of directing you to the search engine, you will be directed to your address local, in this case, we will use mydomain as the domain. ... 127.0.0.1 subdomain.mydomain mydomain Now let's create the blueprint subdomain_blueprint.py from flask import Blueprint sub_blueprint = Blueprint('Subdomain route', __name__) @sub_blueprint.route('/', subdomain='subdomain') def index(): return &quot;This is a subdomain blueprint&quot; Note that in the blueprint decorator, we added subdomain='subdomain' which serves to indicate the subdomain that will be used. Now in main.py let's register the blueprint from sub_blueprint import sub_blueprint app.register_blueprint(sub_blueprint) Now we need to configure our config.py to be able to recognize our locally created domain. from decouple import config SERVER_NAME = config('SERVER_NAME') Basically, we are going to use the python decouple lib so we can dynamically configure the SERVER_NAME. Because of this, we will need to create a .env file with the name SERVER_NAME (it is important to put the .env in .gitignore as it cannot be uploaded to your repository) SERVER_NAME=mydomain:5000 now let's test the domain and subdomain in the browser. Now let's upload this project to git and place the .env in .gitignore echo '.env' &gt; .gitignore echo 'venv' &gt;&gt; .gitignore echo '__py_cache__' &gt;&gt; .gitignore git add . git commit -m &quot; initial commit&quot; git push origin main Go to namecheap and hire a domain following the site's standard procedure. With the domain purchased, we will register it at Cloudflare by first adding the domain name and clicking on &quot;Add a Site&quot;. With the nameservers in hand, let's add it to NameCheap. Now we go config Heroku. It is necessary to create a Heroku account before continuing, creating the account we will log in and add the app by clicking on create a new app. For create app You must first register a credit card on Heroku before proceeding, as there are no more paid plans now. In the first step, put a name for your app and choose the region, then click on Create App. On the next screen, we will choose the heroku cli option to upload our application. &gt;[info] GitHub use &gt;For this example, we are going to use the Heroku CLI as it is the simplest method, but I strongly recommend making a pipeline using Git Hub, and if you need to know how to install the Heroku CLI, just follow the [instructions on the Heroku website](https ://devcenter.heroku.com/articles/heroku-cli), if you are using Linux I recommend using the tarball. Before we continue to configure the CLI, let's put the requirements file, which Heroku will identify to deploy, as we use poetry, we need to export the file. poetry export -f requirements.txt --output requirements.txt Let's also create the Procfile so we can start our app using the app.py from the flask with gunicorn. web: gunicorn app:app Now let's configure the environment variable so that Heroku identifies the name of the server you want to use in my case I'm going to use myfinances.guru. So let's click on Settings and then on Reveals Config Vars. In the KEY field, we will put SERVER_NAME and in value, we will put the domain which in my case is myfinances.guru Then just click on Add and in the sequence we will deploy. To start the Heroku CLI, let's log in using the command below: heroku login It will display a link with a login page in your browser, so just copy and paste and follow the login procedure after you're done just go back to the terminal. Let's add the latest changes to our main branch: git add . git commit -m &quot;chore: add deploy configs&quot; git push origin main Adding a remote for Heroku, in your app the configuration line will appear in my case it is the line below in your case it will be another line: heroku git:remote -a example-subdomain-jonatas Now just push to Heroku with the command below: git push heroku main &gt;[info] Which branch to use for push? &gt;In my case, my branch on Git Hub is main, but on Heroku the example will appear as master, so always put the branch you are using on github. When the deployment is finished it will display a heroku url for this project, in my case it looked like this: remote: https://example-subdomain-jonatas.herokuapp.com/ deployed to Heroku Let's now indicate to Heroku that we are going to use an external subdomain in my case myfinances.guru according to the line below: heroku domains:add myfinances.guru Now with the heroku domain command we verify the target that it will generate to put in the DNS. Now we also add our subdomain: heroku domains:add subdomain.myfinances.guru It will generate another target to be placed on CloudFlare. Now we need to go to Cloudflare and configure this URL using CNAME, in my case it will look like the image below: Now we need to wait a few minutes to propagate the DNS, but once the propagation is complete we can test our application using the domain. With that I close this guide, if you need any other information please let me know. References CloudFlare Documentation Heroku Documentation"},{"title":"30 dias usando Helix","description":"\"Me desafiei a aprender a usar o editor Helix por 30 dias!\"","tags":[],"slug":"30-dias-usando-helix","html":"Veja também no Youtube Olá gente, estou esse mês me desafiando a usar o helix que é um editor baseado em rust por 30 dias. Só pra contextualizar, eu uso vim/neovim a um bom tempo e eu estou montando um material de como configurar o neovim do zero, nesse meio tempo tenho que continuar trabalhando, e eu decidi não usar uma vm pra ir configurando em paralelo enquanto minha config estável contuasse me atendendo. Então resolvi testar um editor novo que é em algumas partes inspirado no vim/neovim pra ir usando. Helix É um projeto feio em rust e tem como principais features, melhorar a parte de multicursos relacionado ao vim/neovim além de já ter uma configuração lsp pronta pra uso, quase como um mason do neovim só que ele em si não instala os server só detecta os mesmos. Alguns desafios Bom primeira coisa que acaba confundindo um pouco é que eu tenho alguns atalhos próprios no neovim e além de ele ter por padrão alguns atalhos estou precisando reaprender a usar do modo dele, uma coisa que é dificil pra mim é desapegar um pouco de algumas formas de navegar do neovim e usar ai fiz no meu obsidian um mapa dos principais atalhos que compartilho com vocês abaixo: Helix Shortcuts `Ctrl`+`,` | Abre a caixa de diálogo de configurações. `Ctrl`+`Shift`+`,` | Salva as configurações atuais. `Ctrl`+`P` | Abre o painel de pesquisa. `Ctrl`+`B` | Abre a barra lateral. `Ctrl`+`F` | Abre a barra de pesquisa do editor. `Ctrl`+`E` | Abre a barra de navegação. `Ctrl`+`T` | Abre uma nova guia. `Ctrl`+`W` | Fecha a guia atual. `Ctrl`+`Shift`+`W` | Fecha todas as guias. `Ctrl`+`J` | Desloca para baixo uma linha. `Ctrl`+`K` | Desloca para cima uma linha. `Ctrl`+`H` | Apaga a palavra anterior. `Ctrl`+`D` | Apaga a letra anterior. `Ctrl`+`C` | Copia o texto selecionado. `Ctrl`+`V` | Cola o texto copiado. `Ctrl`+`X` | Corta o texto selecionado. `Ctrl`+`Z` | Desfaz a última alteração. `Ctrl`+`Y` | Refaz a última alteração. `Ctrl`+`A` | Seleciona todo o texto. `Ctrl`+`E` | Move o cursor até o final do texto. `Ctrl`+`B` | Move o cursor para o início do texto. `Home` | Move o cursor para o início da linha atual. `End` | Move o cursor para o fim da linha atual. `Page Up` | Move o cursor para cima uma página. `Page Down` | Move o cursor para baixo uma página. `Left` | Move o cursor para a esquerda. `Right` | Move o cursor para a direita. `Up` | Move o cursor para cima. `Down` | Move o cursor para baixo. Novos modos No caso do Helix tem dois modos que estou usando que são bastante importantes, primeiro o modo Space que serve pra navegar entre os arquivos e buffers e o Go To mode que serve pra navegar nos arquivos em si, aqui o principal desafio é que muitas das coisas que estão ali eu já tinha uma forma personalizada de trabalhar no neovim, então estou com o trabalho de reaprender os atalhos até ver na documentação se tem alguma forma de personalizar esses comandos para os que eu já estava usando. Config A configuração usa um arquivo .toml e é bem simples de trabalhar com ele vou mostrar as configurações que você configura no .config/helix/config.toml theme = &quot;catppuccin_mocha&quot; [editor] line-number = &quot;relative&quot; mouse = false [editor.statusline] left = [&quot;mode&quot;, &quot;spinner&quot;] center = [&quot;file-name&quot;] right = [&quot;diagnostics&quot;, &quot;selections&quot;, &quot;position&quot;, &quot;file-encoding&quot;, &quot;file-line-ending&quot;, &quot;file-type&quot;] separator = &quot;│&quot; mode.normal = &quot;NORMAL&quot; mode.insert = &quot;INSERT&quot; mode.select = &quot;SELECT&quot; [editor.lsp] enable = true display-messages = false [editor.file-picker] hidden = false [editor.soft-wrap] enable = true max-wrap = 25 # increase value to reduce forced mid-word wrapping max-indent-retain = 0 wrap-indicator = &quot;&quot; # set wrap-indicator to &quot;&quot; to hide it Uma coisa legal ele já consegue pegar vários temas por default e é só passar o nome do tema. Na sessão editor eu deixo o número de linhas relativo pois é útil quando você quer pular linhas e desativo a iterção do mouse. Em editor.statusline eu crio uma linha de status bem simples pra ficar parecida com a que eu usava no neovim. Em editor.lsp eu habilito o linter e desativo as mensagens de progresso do linter na linha de status. Em editor.file-picker eu só desativo a opção de esconder arquivos ocultos. E finalmente me editor.soft-wrap eu habilito algumas opções para fazer a quebra de linha na tela. Configuração dos linters No meu caso eu uso majoritariamente python, typescript e rust como linguagens então precisei configurar globalmente os linters de cada uma das linguagens e preciso chegar usando helix --healthpra ver as configurações ou se quero uma linguagem ou framework especifico uso o comando helix --health pythonpor exemplo. A config das linguagens fica em .config/helix/languages.toml e meu arquivo no momento está assim: [[language]] name = &quot;python&quot; language-servers = [&quot;pyright&quot;, &quot;ruff&quot;] [language-server.pyright] command = &quot;pyright-langserver&quot; args = [&quot;--stdio&quot;] [language-server.pyright.config.python.analysis] typeCheckingMode = &quot;basic&quot; [language-server.ruff] command = &quot;ruff-lsp&quot; [language-server.ruff.config.settings] args = [&quot;--ignore&quot;, &quot;E501&quot;] [language.formatter] command = &quot;blue&quot; args = [&quot;--line-length&quot;, &quot;88&quot;, &quot;--quiet&quot;, &quot;-&quot;] [[language]] name = &quot;rust&quot; [language-server.rust-analyzer.config.check] command = &quot;clippy&quot; Ainda não fiz as configs relativas a typescript, vue, nuxt e svelte por que nesses dias só fiz pequenos ajustes nos projetos que estão usando essa linguagem. No mais essa config ainda estou aprendendo e ela não está 100% preciso trabalhar um pouco em cima dela ainda. Desafios Bom um dos principais desafios no momento é quando preciso de algo que não está na documentação além de ser até bem abrangente ainda preciso caçar algumas coisas. Na parte do lsp deu um trabalhinho instalar o linter globalmente e ainda preciso remover algumas coisas que não nele. Copiar algo do editor e colar por exemplo no navegador no qual estou escrevendo esse artigo não funciona por padrão e ainda não descobri como fazer para habilitar o xclip por exemplo. Além disso eles possuem um artigo de quem está migrando do vim que é bem útil pra quem está começando. Por enquanto é isso e vou atualizando conforme for progredindo aqui. Dia 2 Sobre alguns desafios anteriores Bom descobri que tinha um health check pro clipboard ➜ helix --health clipboard System clipboard provider: wl-paste+wl-copy No meu caso uso o wayland ai uso o wl-copy e estava funcionando, acontece que só usando o atalho y ele não copia pro clipboard no caso precisa usar &lt;Space&gt;+ypara copia-lo. Uma coisa que acho meio perigosa no atalho que eles criaram para deletar caracteres com a letra d é que no vim temos um atalho dd que remove a linha inteira isso pode acabar confundindo, principalmente quem já tem a memória muscular pra fazer isso. Outra coisa meio ruim é que no NeoVIm eu uso muito C+v + um jump para copiar e agora preciso fazer essa sequencia. v + jump + &lt;Space&gt;+y antes eu fazia assim &lt;Shift&gt; + v + jump +y O espaço no final sempre acaba me pegando, mas acredito que é questão de praticar mais também para se adaptar. As vezes me confundo também com o a no caso do vim ele entra no mode de inserção no caractere posterior aqui no helix ele pula uma linha e entra no modo de inserção. Coisas legais que descobri Uma coisa legal que penso em levar pro meu Neovim é ele já fechar parenteses, chaves e colchetes automaticamente. Porém quando estou editando o script do meu curso de rust as vezes da uma dor de cabeça já que estou usando o mkdocs pra trabalhar com ele e alguns marcações não precisam ser fechadas e ele fecha, acredito que deva haver alguma forma de resolver isso só não sei ainda. Uma coisa lega que descobri que consigo jogar o editor pra background e depois voltar, mais tarde descobri que também conseguia fazer isso com o vim por que na verdade é um comando do shell em si. shortcut description Ctrl+z joga o editor pra background fg volta o editor para primeiro plano Sobre o LSP Precisei hoje instalar os servers de svelte e vue npm install -g svelte-language-server npm install -g typescript-svelte-plugin npm install -g @vue/language-server npm install -g prettier Ai aproveitei e adicionei uma configuração extra no meu languages.toml [[language]] name = &quot;vue&quot; auto-format = true formatter = { command = &quot;prettier&quot;, args = [&quot;--parser&quot;, &quot;vue&quot;] } Um ponto importante é que o helix é dividido em 3 partes Language configuration Nessa sessão fica as configurações especificas que você precisa de uma linguagem e a extensão da mesma. Grammar configuration Se tiver uma configuração do tree-sitter disponível ele vai usar normalmente ele vai usar um caminho padrão, no meu caso eu precisei configurar os linters para funcionarem globalmente para o helix conseguir pegar. Queries As queries na verdade também fazem parte do tree-sitter e elas provem o highlight e a edentação da linguagem. fora isso é importando atualizar as gramáticas periodicamente. helix --grammar fetch helix --grammar build Afinal o que é LSP O Language Server Protocol (LSP) é um protocolo de comunicação usado entre um Editor de Código e um Servidor de Linguagem. Sua principal finalidade é permitir a integração eficiente de funcionalidades de análise de código e ferramentas específicas de linguagem diretamente nos editores de código. Como Funciona: Cliente-Server Model: O LSP segue um modelo cliente-servidor, onde o editor (cliente) se comunica com um servidor específico para uma linguagem de programação. Comunicação via JSON-RPC: As mensagens são trocadas entre o cliente e o servidor usando o formato JSON-RPC, o que facilita a implementação em várias linguagens. No nosso caso o helix tem um client LSP e precisamos instalar os servidores para usa-los com ele. Afinal o que é o Tree-sitter O Tree-sitter é um parser de código incremental e gerador de árvores de sintaxe. Ele é projetado para ser eficiente, preciso e capaz de lidar com linguagens de programação complexas. Como Funciona: Análise Incremental: O Tree-sitter realiza análises incrementais, o que significa que, ao modificar o código-fonte, apenas as partes afetadas são reanalisadas, proporcionando uma resposta mais rápida. Geração de Árvore de Sintaxe: Ele gera uma árvore de sintaxe para o código-fonte, representando a estrutura hierárquica do mesmo. Ele é muito importante para eu conseguir navegar pelo código através das arvores que ele gera. Navegação Uma coisa nova é a navegação ela tem algumas coisas parecidas com o vim e outras não e precisei fazer uma tabela de navegação para me ajudar a me orientar. shortcut description x seleciona linha v entra no select mode C Seleciono as mesmas palavras com multi-cursor s Se estiver com linhas selecionadas da pra buscar um padrão dentro da seleção para fazer alteração Buscas shortcut descipriton Space+/ Busca nos arquivos Space+f Busca pelo nome do arquivo Uma coisa não muito boa, é que ele ainda não tem uma forma de fazer uma busca dentro dos arquivos, isso é algo que acabo usando muito em projetos grandes então é um ponto ainda pra melhorar. Ele possui uma busca, mas em alguns casos acabou não dando muito certo. Dica extra Você tem um tutorial bem legal se você é novato em editores como o vim que é o modo tutor dele: helix --tutor É sempre interessante pra quem quer começar olhar esse tutor, no caso do vim também tem e recomendo a todos que olhem. Próximos cápitulos Bom acredito que essa semana foi uma semana pra se adaptar e pensar algumas coisas de modo diferente nesse semana tenho um pouco mais de trabalho planejado com python e svelte então vou explorar um pouco mais o trabalho com os buffers e registradores além das diversas features relacionadas a manipular a seleção de código e multi cursores e dar uma refinada na minha configuração e criar alguns atalhos, então nos vemos na próxima semana. Semana 2 Bom passamos a semana 2 com o hélix, essa semana com um trabalho mais afundo no editor. Criando atalhos no space mode Bom sinto falta de alguns atalhos de navegação, como no neovim se usa muito a memoria muscular eu decidi criar alguns atalhos no meu config.toml [keys.normal.space] w = &quot;:write&quot; # Salvar buffer com espaço + w q = &quot;:bc&quot; # Fechar buffer z = &quot;:bp&quot; # Ir pro próximo buffer x = &quot;:bn&quot; # Ir pro buffer anterior No caso a chave keys.normal.space representa as teclas de ação pra usar no space mode no modo normal. Ai criei atalhos pra navegar pra frente e para trás nos buffers, fechar um buffer e salvar um buffer, o que fez ajudar muito meu trabalho no dia-a-dia. Desafios Uma coisa não muito legal que estava me acontecendo é que eu criava uma exception num arquivo em python e quando ia usa-lo o helix não estava identificando para importar. Descobri que o meu languages.toml não estava funcionando, agora que estava trabalhando num projeto mais focado eu estava vendo que eu olhava o server e aparecia pylsp que é o default e não o pyright + ruff ou mesmo o svelte estava dando um monte de erro, ai percebi que tinha colocado language.toml ao invés de languages.toml então ele não estava usando a minha config ajustei ai começou a funcionar corretamente. Trabalhei bastante com svelte essa semana e auto format não funcionou direito assim como o auto-complete então vou ter que nas próximas semanas se esforçar um pouco mais. Coisas Legais Melhorando um pouco minha tabela com as navegações que mais uso: shortcut description x seleciona linha v entra no select mode C Seleciono as mesmas palavras com multi-cursor s Se estiver com linhas selecionadas da pra buscar um padrão dentro da seleção para fazer alteração [f ou ]f pula funções [t ou]t pula classes Também os atalhos mais usados no go to mode shortcut description d vai pra definição da função ou classe r vai aonde referencio a função ou classe a vou pro ultimo arquivo acessado m vou pro último arquivo modificado Outra coisa que uso muito no neovim é mudar o texto dentro de um parenteses ou aspas e aqui existe um modo pra fazer isso é que o match mode usando a tecla mno modo normal. shortcut description r muda o texto no que está dentro do padrão d deleta o que está dentro do padrão a seleciona tudo junto com o padrão i seleciona tudo dentro do padrão Quando digo o padrão é o () {} [] &quot;&quot; '' Sendo sincero isso está um pouco difícil de acostumar ainda acho mais funcional o jeito do vim de trabalhar com padrões. Concluindo Essa semana trabalhei mais com padrões e melhores mais meu fluxo de trabalho isso me ajudou a ser mais produtivo com a ferramenta. A parte de desenvolver com svelte não esta sendo muito boa então vou ter que me concentrar em ver qual o problema. No caso por exemplo do nuxtjs ele funcionou bem. Semana 3 Ola gente compartilhando como foi minha terceira semana, como foi black friday e estava trabalhando num projeto não consegui explorar tanto em expandir meus recursos mais sim em trabalhar com o qie ja conhecia. Desafios Bom a parte de selecionar código algumas vezes me dava trabalho, por exemplo quando eu queria selecionar todo o arquivo se eu usava o v as vezes não pegava tudo e usando x não me parece uma ideia muito legal e em arquivos grandes se mostra algo não muito inteligente. Lembrando um chefe meu que usava vim, &quot;tudo no vim da para fazer com dois comandos.&quot;. Provavelmente não estava fazendo do jeito certo e tem um jeito melhor de fazer. Outra coisa que sinto falta é uma indicação visual nas tabs, estava com várias tabs abertas, mas não aparecia a tab que eu estava usando em destaque ai não sabia se estava salvo o buffer ou não e isso as vezes me deu uma dor de cabeça. Coisas legais É incrível como usar por um tempo um editor você acaba trabalhando bem com seu fluxo. Essa semana eu precisei codar bastante e as coisas começam a ficar mais naturais. Parte de lint estava funcionando bem assim como as buscas o que ajuda a ficar produtivo, outra coisa que usei bastante foi o multi-cursor que realmente é algo bem útil no helix. Acabei colocando um server novo agora para ter uma camada de buffer de comandos Pra isso precisei instalar o simple-completion-language-server Ajustar meu languages.toml [language-server.scls] command = &quot;simple-completion-language-server&quot; config = { max_completion_items = 20, snippets_first = false } [language-server.scls.environment] RUST_LOG = &quot;debug,simple-completion-langauge-server=debug&quot; LOG_FILE = &quot;/tmp/completion.log&quot; [[language]] name = &quot;python&quot; roots = [&quot;pyproject.toml&quot;] language-servers = [&quot;scls&quot;, &quot;pyright&quot;, &quot;ruff&quot;] [language-server.pyright.config.python.analysis] typeCheckingMode = &quot;basic&quot; [language-server.ruff] command = &quot;ruff-lsp&quot; [language-server.ruff.config.settings] args = [&quot;--ignore&quot;, &quot;E501&quot;] [language.formatter] command = &quot;blue&quot; [[language]] name = &quot;rust&quot; [language-server.rust-analyzer.config.check] auto-format = false language-servers = [&quot;rust-analyzer&quot;, &quot;scls&quot;] command = &quot;clippy&quot; [[language]] name = &quot;vue&quot; auto-format = true formatter = { command = &quot;prettier&quot;, args = [&quot;--parser&quot;, &quot;vue&quot;] } [[language]] name = &quot;svelte&quot; auto-format = true formatter = { command = 'prettier', args = [&quot;--plugin&quot;, &quot;prettier-plugin-svelte&quot;, &quot;--stdin&quot;] } [[language]] name = &quot;git-commit&quot; language-servers = [ &quot;scls&quot; ] Ele além disso ele me da alguns snipets do código. Bom por enquanto ainda não tive muita fluência com o svelte ainda, trabalhei um pouco no meu blog e o auto-complete não estava tão legal, isso é uma coisa que sinto falta que tinha no neovim que são alguns snippets. Bom esse texto foi mais curto foi muito mais usando que qualquer coisa e a experiência está sendo interessante, convido você testar também ele pois é um editor muito interessante. Até semana que vem. Semana 4 Olá, estamos na semana 4 e foi uma jornada muito interessante até aqui. Bom estou muito mais adaptado ao hélix alem de ainda ter velhos hábitos como apertar yy pra copiar ou DD pra deletar, principalmente quando eu estava querendo fazer algo mais rápido com pressa. Claro que poderia criar um atalho pra fazer esses comandos mas acabei não fazendo. Acho que no final dessa semana uma coisa que fiquei devendo bastante é ler a documentação com calma, eu meio que fui alterando e lendo e como não reservei um tempo pra ler tudo com calma fica o sentimento que poderia tirar mais do editor. Algumas coisas que não consegui resolver Como nem tudo são flores nos casos que abri muitos buffers fica um pouco difícil as vezes de visualizar em qual arquivo você está não explorei a fundo a customização nativa dele, talvez consiga algo melhor do que o default mas, ai foi um problema pra mim. Outro problema foi o svelte e o tailwind o primeiro ele ate me dava algumas coisas no auto complete porem não tudo, no caso do tailwind o meu problema foi ele não dar autocomplete. No caso de ele vir com o client lsp pra mim foi uma faca de dois gumes por um lado se você tem clients qie ja esta acostumado a instalar globalmente é muito bom, porem no caso do python por exemplo eu uso cliente diferentes pra projetos diferentes e ai não fica muito legal trabalhar assim. Alguns ajustes Bom como de costume em editores com arquivos de configuração é legal ver as configurações dos outros pra buscar ideias, no meu caso dei uma olhada no github no meu amigo Bruno Rocha e fiz algumas alterações no meu arquivo do config.toml color-modes = true para cada modo ele muda a cor gutters = [&quot;diff&quot;, &quot;diagnostics&quot;, &quot;line-numbers&quot;, &quot;spacer&quot;] mostrar algumas diferenças visuais entre as versões de um arquivo Conclusão O hélix é um editor muito promissor, segue a filosofia do vim e kakaroune principalmente no segundo. Tenta trazer coisas novas como ter um client lsp já funcional, adicionou o suporte a multi servers que ajudou muito. Ainda sinto falta DD um sistema de plugins pra conseguir entender algumas coisas e trazer funcionalidades que ele ainda não tem, mas entendo qie ele esta querendo trazer uma experiencia mais &quot;baterias inclusas&quot; do que o neovim e arriscou dizer que é uma boa opção pra iniciantes por ser de algumas formas mais amigável que o neovim e mesmo assim você precisando aprender a configurar seu editor. Alem disso ainda tem coisas que me fazem continuar com o com como um suporte melhor ao svelte e ter um autocomplete bom pro tailwind. Nos próximos meses devo refazer minha config do zero pro neovim e enquanto isso devo continuar usando o hélix pois ele é muito bom e talvez ate contribuir com ele. Convido você que quer aprender a usar um editor de terminal experimente o hélix primeiro e depois vá pro vim ele tem uma configuração mais simples e você vai aprender a maior parte da navegação por ele. Não me leve a mal ainda gosto mais do neovim porém vejo que muitos novatos sofrem pra configurar o neovim no dia a dia o hélix é uma boa opção de começar a usar com menos configuração enquanto ajusta seu neovim aos poucos. Estero que quem acompanhou essa jornada se inspire a conhecer também."},{"title":"Rust Descomplicado: Desvendando os mistérios dos tipos básicos","description":"\"Neste artigo, vamos explorar os tipos primitivos de Rust, um dos blocos fundamentais para trabalhar nesta linguagem.\"","tags":[],"slug":"rust-descomplicado-desvendando-os-miste-rios-dos-tipos-ba-sicos","html":"Rust Descomplicado: Desvendando os Mistérios dos Tipos Básicos Olá tudo bem? Hoje quero falar com você sobre os tipos primitivos em rust. Tipos primitivos são em linguagens de programação como Rust, são os tipos básicos de dados que são fornecidos pela linguagem e não são construídos a partir de outros tipos. Cada tipo tem um tamanho determinado para armazenar suas informações e a partir desses tipos básicos o rust consegue criar os outros tipos que ele usa, e claro você também pode criar seus próprios tipos. Mas, sem enrolação vamos ao video. Inteiros (Integers) O primeiro tipo que vamos falar são os tipos inteiros, e sim no plural pois temos vários tipos inteiros. Os números inteiros são divididos em dois grupos os números inteiros com sinal também chamados de Signed (representa positivos, negativos e zero) e os números inteiros sem sinal também chamados de Unsigned (Representa positivos e zero). Para os inteiros Signed temos: i8: 8 bits que varia entre -128 a 127. i16: 16 bits que varia entre -32,768 a 32,767 i32: 32 bits que varia entre -2,147,483,648 a 2,147,483,647 i64: 64 bits que varia entre -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807. i128: 128 bits que varia entre -170,141,183,460,469,231,731,687,303,715,884,105,728 a 170,141,183,460,469,231,731,687,303,715,884,105,727. fn main() { // i8 let number_i8: i8 = -128; println!(&quot;i8: {}&quot;, number_i8); // i16 let number_i16: i16 = -32768; println!(&quot;i16: {}&quot;, number_i16); // i32 let number_i32: i32 = -2147483648; println!(&quot;i32: {}&quot;, number_i32); // i64 let number_i64: i64 = -9223372036854775808; println!(&quot;i64: {}&quot;, number_i64); // i128 let number_i128: i128 = -170141183460469231731687303715884105728; println!(&quot;i128: {}&quot;, number_i128); } Para os interior Unsigned temos: u8: 8 bits que varia entre 0 a 255. u16: 16 bits que varia entre 0 a 65,535. u32: 32 bits que varia entre 0 a 4,294,967,295. u64: 64 bits que varia entre 0 a 18,446,744,073,709,551,615. u128: 128 bits que varia entre 0 a 340,282,366,920,938,463,463,374,607,431,768,211,455. fn main() { // u8 let number_u8: u8 = 255; println!(&quot;u8: {}&quot;, number_u8); // u16 let number_u16: u16 = 65535; println!(&quot;u16: {}&quot;, number_u16); // u32 let number_u32: u32 = 4294967295; println!(&quot;u32: {}&quot;, number_u32); // u64 let number_u64: u64 = 18446744073709551615; println!(&quot;u64: {}&quot;, number_u64); // u128 let number_u128: u128 = 340282366920938463463374607431768211455; println!(&quot;u128: {}&quot;, number_u128); } Fora isso temos o tipo usize e isize que representam palavras no formato do processador que está sendo usado ou seja 32 bits pra processadores de 32 bits e 64 bits para processadores de 64 bits. O uso de isize é útil quando você está lidando com índices de coleções ou quando deseja garantir que seu código seja eficiente em diferentes arquiteturas sem ter que se preocupar com o tamanho exato do inteiro. Suponha que você queira imprimir o tamanho de um vetor em termos de número de elementos, e para isso, você pode usar o tipo isize para garantir portabilidade. Aqui está um exemplo: rust fn main() { let vetor = vec![1, 2, 3, 4, 5]; // Usando .len() para obter o tamanho do vetor, que retorna um usize. // Convertendo para isize para impressão e operações posteriores. let tamanho: isize = vetor.len() as isize; println!(&quot;O tamanho do vetor é: {}&quot;, tamanho); // Aqui, apenas para ilustrar, vamos fazer uma operação simples. let novo_tamanho = tamanho + 10; println!(&quot;Se adicionar 10, o novo tamanho é: {}&quot;, novo_tamanho); } Neste exemplo, usamos isize para representar o tamanho do vetor. Ao fazer isso, garantimos que o código funcione tanto em arquiteturas de 32 bits quanto de 64 bits, adaptando-se automaticamente ao tamanho da palavra do sistema. Um parenteses: Os termos &quot;32 bits&quot; e &quot;64 bits&quot; referem-se ao tamanho da palavra de um processador, o que, por sua vez, influencia o tamanho máximo de dados que o processador pode processar em uma única operação e a quantidade máxima de memória RAM que o sistema operacional pode endereçar. Ponto Flutuante (Floating-Point) Para pontos flutuantes vamos ter: f32: Ponto flutuante de precisão simples (32 bits). f64: Ponto flutuante de precisão dupla (64 bits). É o padrão para números decimais em Rust. Em computação, os termos &quot;precisão simples&quot; e &quot;precisão dupla&quot; referem-se ao número de bits usados para representar números de ponto flutuante em um computador. No contexto do Rust e da maioria das linguagens de programação, esses termos são geralmente associados aos tipos f32 e f64, respectivamente. Precisão Simples (f32): Utiliza 32 bits para representar um número de ponto flutuante. Oferece uma precisão de aproximadamente 7 dígitos decimais significativos. É mais eficiente em termos de uso de memória e pode ser mais rápido em algumas operações devido ao tamanho menor. fn main() { // Exemplo com f32 let numero_f32: f32 = 3.14159; // Aproximadamente Pi println!(&quot;Valor usando f32: {}&quot;, numero_f32); // Outro exemplo com f32 let outro_f32: f32 = 123.456789; // Aproximadamente 123.456789 println!(&quot;Outro valor usando f32: {}&quot;, outro_f32); } Precisão Dupla (f64): Utiliza 64 bits para representar um número de ponto flutuante. Oferece uma precisão muito maior, aproximadamente 15 a 17 dígitos decimais significativos. Por ser mais preciso, é geralmente preferido em aplicações que exigem alta precisão, como cálculos científicos ou financeiros que envolvem números muito grandes ou muito pequenos, ou quando se deseja evitar erros acumulados em cálculos longos. fn main() { // Exemplo com f64 let numero_f64: f64 = 3.141592653589793; // Valor mais preciso de Pi println!(&quot;Valor usando f64: {}&quot;, numero_f64); // Outro exemplo com f64 let outro_f64: f64 = 123456789.987654321; // Número grande com precisão dupla println!(&quot;Outro valor usando f64: {}&quot;, outro_f64); } Caractere (Character) Para representar um caractere temos o tipo char e é usado para representar 1 caractere. Temos os tipos str e String mas, eles são usados para representar um grupo de caracteres o tipo primitivo é apenas o char. O char armazena 4 bytes e é usado para representar um caractere Unicode. fn main() { let letra = 'A'; println!(&quot;Essa é a letra: {}&quot;, letra); } E o que é Unicode? Unicode é um padrão de codificação de caracteres universal que visa definir um único código numérico para cada caractere de qualquer sistema de escrita do mundo. A ideia por trás do Unicode é criar uma forma de representação padronizada para caracteres de todos os idiomas e símbolos usados globalmente. Um exemplo armazenando o kanji Megami do japones: fn main() { let megane = 'u{76EE}'; println!(&quot;{}&quot;, megane); } Um exemplo armazenando um emoji: fn main() { let emoji_sorriso = 'u{1F603}'; println!(&quot;{}&quot;, emoji_sorriso); } Booleano (Boolean) O tipo booleano é usado para presentar como o nome já diz um valor booleano. Sendo true para verdadeiro e false para falso. fn main() { let verdadeiro = true; let falso = false; println!(&quot;Verdadeiro -&gt; {}, Falso -&gt; {}&quot;, verdadeiro, falso) } Bom o post de hoje é isso nos vemos na próxima semana."},{"title":"52 semanas de planejamento em 2023","description":"\"As ferramentas que estou usando no meu workflow de trabalho\"","tags":[],"slug":"52-semanas-de-planejamento-em-2023","html":"52 Semanas de planejamento em 2023 Olá estamos na primeira semana do ano e muita gente faz resoluções de ano novo e cria planos, e talvez você tenha colocado como meta se planejar melhor. Por conta dissso quero te ajudar e explicar algo que fiz em 2023 e foi uma grande conquista. Bom eu consegui me planejar em todas as 52 semanas definindo um foco para cada semana e isso pra mim foi algo inédito. Veja bem cada semana eu me sentei por um breve período e defini todos meus compromissos agendados, planejamentos e lembretes além é claro de qual seria o meu foco em cada semana. Só pra sua curiosidade essa primeira semana de 2023 meu foco foi criar o meu primeiro vídeo no youtube nesse ano de 2024 sobre esse tema. Mas, antes de explicar como eu faço meu planejamento semanal, gostaria de falar que nesse ano de 2024 estou iniciando minha jornada como game developer que é um dos meus grandes objetivos para esse ano e comecei com um desafio de aprender bevy engine o suficiente para fazer um tutorial no meu canal do youtube no final desse período, mas o dia a dia nessa jornada vou publicar no meu youtube além do meu servidor no discord eu convido você para me acompanhar. Vale reforçar que esse planejamento me ajuda muito a me guiar com minha priorização do que vou fazer e o tempo que vou dedicar para cada assunto que preciso fazer na vida seja na vida pessoal ou no trabalho o que no método que uso é chamado de contexto. Então para iniciar o método que uso é o MVO feito pela Thais Godinho onde trabalhamos lá com metas, objetivos e projetos vendo coisas a longo prazo até o planejamento do dia, mas hoje vamos focar no planejamento da semana e do dia. Pra fazer esse planejamento é possível usar várias ferramentas online e também no papel mas, hoje vou usar o google calendar que é a ferramenta que uso no dia a dia. Eu sou uma pessoa que gosta muito de usar ferramentas open source, mas no caso do calendário até hoje não consegui uma ferramenta de calendário que funcionasse comigo e tenha uma boa sincronização com o google calendar pois fora meu planejamento eu tenho o calendário da minha esposa e filho para acompanhar. Caso você conheça alguma ferramenta legal que faça isso pode colocar nos comentários eu adoraria experimentar. Então inicialmente com uma conta do google já criada eu entro no Google Calendar, em português fica como Google Agenda ai no software já vem com uma agenda padrão que é o que a maioria usa, nele eu renomeio para &quot;Pessoais&quot;, ai crio duas novas agendas uma chamada &quot;Planejados&quot; coloco uma cor cinza e outra chamada &quot;Lembretes e Informações&quot; e coloco um tom amarelo. Ai como funciona cada agenda? Agendados: São compromissos no qual eu tenho um horário marcado, como uma reunião, um horário no dentista ou qualquer outra coisa que tem um horário definido. Planejados: São coisas que você precisa fazer mas, não tem um horário fixo, pode ser arrumar a casa, um projeto que você está trabalhando ou mesmo um horário pra estudar por exemplo. Também deslocamento pra um compromisso externo eu defino um bloco planejado pois além de um lembrete do horário que preciso sair tenho uma forma visual de ver o tempo que planejei para chegar no local. É importante também pensar que essa agenda você não vai colocar a atividade em si por exemplo eu estou aprendendo a bevy engine, não vou criar um evento &quot;Setup do projeto&quot; outro &quot;Criar menu inicial&quot;, outro &quot;Importar assets&quot; eu vou apenas criar um evento chamado Bevy e ai as atividades que preciso fazer eu uso outras ferramentas. Lembrete e informações: São atividades que preciso fazer no dia e não tem um horário especifico como pagar uma conta, jogar o lixo fora ou ver o status de algum pendencia no site do governo por exemplo. Importante reforçar de que como esses compromissos não tem uma hora definida eu deixo como um evento do dia inteiro no calendar. Como disse em cada semana eu defino um foco e ele é um evento do tipo &quot;Lembretes e Informações&quot; no meu calendário, então eu defino ele como um evento do dia inteiro e coloco o início dele no domingo e o final no sábado. E como ele funciona? O foco da semana é sua bussolá ele vai aparecer em todos os dias no seu calendário e é um exercício diário para você ver se está priorizando atividades do seu foco no dia a dia ou se está desviando para outro caminho. Com isso como funciona o meu planejamento? Eu na semana atual defino a próxima semana então já vejo os compromissos que tenho que são agendados, crio blocos da agenda de planejados para as atividades e finalmente vejo o que eu preciso lembrar de fazer como pagar uma conta e coloco como lembrete. Claro que nem tudo precisa ser feito de uma vez só há algumas coisas que vão aparecendo no decorrer da semana que vou colocando para as próximas semanas. O que eu aprendi em 52 semanas de planejamento? Eu aprendi algumas coisas depois dessas 52 semanas e fui ajustando e aprendendo no decorrer das semanas. Há semanas que seu foco vai ser sobreviver: Há momentos na nossa vida que estamos num turbilhão de problemas que tudo está caótico e realmente não conseguimos focar em nada, nesses caso eu coloca como foco &quot;sobreviver&quot; pois, o foco era simplesmente conseguir passar por aquele momento difícil. E é importante perceber se você passou mais de uma semana com o foco em sobreviver, vale a pena repensar na sua semana ou mesmo procurar ajuda. Planeje seus descaço: Mesmo férias é importante planejar e não digo de planejar viagens e tal, mas ver compromissos que ou coisas que você precisa fazer nas suas férias. E caso não tenha nada mesmo pra fazer só coloque como foco &quot;Relaxa&quot;. Não faça a agenda Tetris: É importante criar intervalos entre um compromisso e outro no qual você pode usar pra beber uma água, ir no banheiro ou mesmo responder suas mensagens. Lembre-se você não é uma máquina, essas pequenas pausas entre os eventos são importantes no seu dia a dia. As vezes você não vai conseguir seguir seu foco: Há semanas que você se planejou e organizou mas, tudo mudou. As vezes acontecem coisas externas no qual não podemos controlar e você vai precisar replanejar tudo ou mesmo descartar todo o planejamento já feito e está tudo bem. O importante é ver o que você não pode fazer que precisa mover pra próxima semana e o que você vai deixar pra trás mesmo. A vida é dinâmica então não da pra seguir sempre um plano a risca. Caso queira ver o material original desse método o link vai estrar na descrição. Então é isso que queria lhe mostrar, caso queira ver mais conteúdos como esse pense em se inscrever no canal e ativar o sininho e se quiser trocar uma ideia sobre organização pode entrar no nosso servidor no discord."},{"title":"Por que eu abandonei o desafio de 12 meses?","description":"\"Um breve resumo da minha vida e as dificuldade em fixar um compromisso!\"","tags":[],"slug":"por-que-eu-abandonei-o-desafio-de-12-meses","html":"O desafio No começo de 2022 eu me propus a fazer um desafio de prática deliberada durante 12 meses com o objetivo de fazer vários pequenos projetos nesse periodo e no final eu queria conseguir lançar meu primeiro jogo na steam. No começo estava tudo bem, fiz o primeiro projeto em janeiro, porém mesmo ele, acabei mudando muito o escopo durante o processo. Pois eu queria refatorar um template de fastapi para ter mais opções e tal, depois pensei em focar em fazer um cli e acabou virando uma pr para o projeto do fastapi, que no final nem foi aceito pois a comunidade me convenceu que fazer um cli oficial não faria sentido e até achei uma solução mais simples usando o make. Enfim, eu deveria ter feito uma retrospectiva mais detalhada, mas eu não a fiz por que fiquei chateado com a pr, o problema foi um pouco mais embaixo. Cavando esse buraco Durante esse trabalho eu tinha me proposto fazer duas horas por dia entre as 20 e as 22 pois normalmente meu filho estaria dormindo e ficaria tudo bem. O que foi bem durante as primeiras semanas, só que comecei a ter algumas dificuldades. O tempo que estava separado pra isso foi sendo consumido por muitas outras atividades, pior que em tese eu sabia que precisava fazer essas atividades, só estava talvez me enganando um pouco. Fui fazendo as lives, e foram acontecendo problemas, uma hora doente, outra o bebe chora, outra tem que limpar a casa, outra preparar as refeições e quando vejo estou exausto e me arrastando por ai. Nem tudo funciona como planejado Primeira dificuldade foi que peguei covid, cheguei até fazer algumas lives do desafio com covid sem saber mas, depois do covid fiquei bem cansado por um tempo, com isso o agravante que toda a familia também pegou, acabei necessitando investir um tempo ficando com minha familia cuidando deles. Segundo ponto foi meu esgotamento por conta do trabalho, entrei numa situação do trabalho onde algumas decisões acabaram me desgastando e me deixando exausto. Chegou um ponto que muitas vezes ia por meu filho pra dormir e acabava dormindo junto com ele, outras vezes eu ia conseguia apenas fazer os trabalhos domesticos e já não aguentava mais ficar acordado. Esse stress estava (ainda está) me consumindo muito. Ultimo ponto que vem me trazendo dificuldades é que hoje estou sem um escritório, na verdade sem nenhuma casa. Ano passado fui pra casa da minha sogra ficar um tempo lá e nesse momento estou na casa da minha mãe, no futuro devo estar indo pra uma casa fixa na alemanha, o que me leva a pensar que posso ter problema pra fazer lives por conta do fuso horario. Mudanças e compromisso Esse post não é pra ficar justificando com os problemas, já que cada um tem seus problemas e acredito que muita gente que fixa compromisso ou faz lives periodicamente tem seus problemas. Mas, queria deixar tambem algumas reflexões que tive durante esse período: Muitas atividades: Além do meu trabalho, tenho a responsabilidade de fazer atividades domésticas, ficar com meu filho, ficar com minha esposa, estudar inglês, estudar sobre autismo e além disso preciso reservar um tempo de fazer algo só pra mim. Muito abrangente: Fora os meus estudos de algoritmos, eu quero estudar rust e lua, design de jogos, pixelart, front frameworks e etc eu vejo que preciso direcionar mais os estudos por conta do tempo. Com isso tenho a conclusão que não consigo fazer de seg a sex 2 horas por dia de estudo focado, na verdade não consigo todos os dias e nem duas horas. Além disso nesse momento desisti um pouco da ideia de tentar fazer lives periódicas pelo simples fato que não tenho hoje um ambiente minimo pra fazer uma live e o tempo, pra quem viu algumas das minhas lives eu algumas vezes tinha que sair pra ver meu filho chorando já que ele ainda tem dificuldade de dormir sozinho e isso acaba atrapalhando a live em si, pra isso vou esperar realmente ter um momento oportuno pra voltar. Está tudo perdido entâo? Bom acredito em algo que minha esposa me fiz &quot;Quem quer da um jeito!&quot;, com isso sei que tenho problemas em manter a periodicidade relacionada aos dias, porém consigo usar um ciclo de estudos espaçado. Como funciona? Bom vou escolhar por exemplo três assuntos (python, autismo e inglês), monto um plano de estudo pros 3 assuntos onde cada ciclo tenha entre 20 e 30 min, com isso estudo 30 min de python, se tiver tempo vou pra próxima e assim por diante. Pode ser que faça um assunto em um dia, depois no dia seguinte faça os 3, no outro não faço nada, no outro faço dois ciclos. A ideia é ter menos projetos e mantendo eles pequenos (alguns não muito), além de tentar ir equilibrando os pratos da vida. Meu plano Bom já tenho 3 projetos de software, estou preparando um curso, tenho os desafios de aprender o basico de programação usando jogos e o rpg-api, tenho estudos de autismo, estudo do inglês além disso tenho minhas leituras (que não deixam de ser técnicas), o ponto é que vou diminuir bem o ritmo e não vou me comprometer com a twitch por enquanto. Vou tentar usar o mastodon pra ser meu diário de desenvolvimento, mostrando meus pequenos avanços e tentar primeiro focar no curso, quando terminar ele vou focar nos desafio e por ultimo vou focar nas apis. O ponto é por mais que queira produzir muito sobre desenvolvimento e ser altamente comprometido com minhas metas, quando se tem outras pessoas dependendo de você a coisa fica mais complicada, e nem falo do meu caso, penso em tanta gente em situações muito mais complicadas que eu e fazem um esforço herculeo pra conseguir aprender algo pra melhorar a vida da sua familia. Meu caso sei que posso ajudar muita gente, mas digamos há muitas outras pessoas que conseguem fazer o que eu quero fazer e melhor, minha prioridade sempre vai ser minha familia, se esse projeto atrapalhar a dinamica familiar é por que não vale ser trabalhado no momento. Conclusão Além de tudo a mensagem que queria passar é positiva, tente dar um jeito nos seus planos as vezes vale sim congelar ele, as vezes diminuir o ritmo só não perca eles pelo caminho se você realmente quer algo, estou praticamente a 3 anos num ensaio de começar a fazer jogos que é um sonho que tinha quando entrei na faculdade, sei que sou capaz e vou conseguir, mas sei que hoje com meus 34 anos, casado e um filho autista que eu preciso ser o melhor pai/esposo quanto eu conseguir. Isso não quer dizer abandonar tudo, mas achar um ponto de equilibrio onde consiga tocar os projetos pessoais e também cuidar da minha familia e das minhas responsabilidades. Enquanto isso continuamos a nadar!"},{"title":"Desafio de prática - Escopo Fevereiro","description":"\"Escopo Inicial - Fevereiro\"","tags":[],"slug":"desafio-de-pra-tica-escopo-fevereiro","html":"Por que? Atender demandas de um cliente antigo de um projeto já criado Aplicar o método da refatoração Melhorar o conhecimento em GitHub Actions Bom o objetivo desse projeto é atender algumas demandas que já me foram pedidas num projeto antigo fast-ecommerce. O objetivo é transformar num monorepo, ajustar testes, criar features e fazer pequenos refactors durante o processo. O que? Conceitos Testar a migração do vue 2 para o vue 3 Aprender a gerar um testes de unidade no GitHub Actions Exercitar refactors Aqui basicamente tem estudos mais focados em testes e GitHub Actions, mas o projeto vai ser mais focado na prática. Fatos Montar um pré-commit no projeto Adicionar o projeto badges de build, dependencias e analise estática O projeto front precisa ser migrado para vue3 Os projetos precisam ficar num monorepo O projeto front precisa remover dependências do cliente O projeto back precisa sofrer alguns refactors O projeto front precisa aceitar scripts do tipo typescript Ajustes sugeridos no sonarcloud Procedimentos Reforçar conceitos de arquitetura Reforçar conceitos de teste Reforçar os conhecimentos de vue3 Reforçar os conhecimentos de typescript Como? Vue3 migrate Rodar script de migração Resolver conflitos Bônus - Fazer refactors para composition API Typescript: Refatorar scripts já usando typescript GitHub Actions Rodar testes de unidade (sem db) Rodar o coverage Ajustes no sonarcloud Git Rodar o prospector Rodar o safety Basicamente é um projeto focado em atender uma demanda, montar features, e fazer melhorias."},{"title":"Desafio de prática - Escopo Janeiro","description":"\"Escopo Inicial - Janeiro\"","tags":[],"slug":"desafio-de-pra-tica-escopo-janeiro","html":"Por que? Melhorar o conhecimento em python Montar minha primeira lib no pypi Melhorar o conhecimento em GitHub Actions Bom o objetivo desse projeto é conseguir completar a talvez unica fase prevista no projeto de templates fastapi, assim montar o exemplo da documentação do fastapi que tem apenas o main.py e o meu exemplo melhorado do repositório que mencionei, além disso quero usar uma ferramenta de script como o typer do próprio criador do fastapi pra adicionar as funcionalidades: add template, inicializar/gerar/rodar migrations e rodar o app do template. Como o template sem o cookiecutter está pronto o maior trabalho vai ser fazer ele funcionar com o cookiecuter em si, além de fazer os testes rodarem via github actions. O que? Conceitos Aprender typer Aprender a gerar um teste de unidade no GitHub Actions Publicar uma lib no PyPi Aqui basicamente vou estudar o typer que é a ferramenta de script feita pelo criador do fastapi, aprender a gerar os testes de unidade sem containers via GitHub Action e por fim como publicar uma biblioteca no PyPi. Fatos Montar um pré-commit no projeto Adicionar o projeto badges de build, dependencias e analise estática O projeto precisa ser desenvolvido como lib O projeto precisa poder criar um template O projeto precisa poder iniciar - gerar - migrar as migrations do bd O projeto precisa poder iniciar o projeto com uvicorn Procedimentos Reforçar conceitos de OO Reforçar conceitos de teste Reforçar o conhecimento em cookiecuter Reforçar conhecimentos em desenvolvimento web com python Como? Cookiecutter Gerar 2 projetos diferentes Opções do poetry Adicionar como o exemplo o projeto design api Typer: Criar o prefixo &quot;fast&quot; Receber paramêtros (create | db [init/make/migrate] | runserver) GitHub Actions Rodar testes de unidade (sem db) Rodar o coverage Adicionar o sonarcloud Git Rodar o prospector Rodar o safety Basicamente nesse projeto é consultar as documentações e aplicar os conceitos acima, estimativa inicial pra todos esses passo é fazer tudo em 20 horas."},{"title":"Desafio de prática - Plano","description":"\"Meu desafio para 2023\"","tags":[],"slug":"desafio-de-pra-tica-plano","html":"Desafio de prática Olá, bom estou oficialmente abrindo meu desafio de prática público de 2022. Como funciona? As regras eu disponibilizei nesse link, ainda posso melhorar um pouco ele mas, o resumo está lá. A idéia é fazer um compromisso público de alcaçar um objetivo, usando projetos no máximo mensais onde vou praticar determinadas habilidades para alçar um objetivo. A ideia desse desafio é fazer um compromisso para praticar algumas habilidades, isso não contabiliza horas de estudo especifico, durante cada sessão de prática ele vai ter objetivos e a ideia caso aconteça algum bloqueio é tentar se desbloquear apenas vendo as documentações de sistemas. Além disso trabalhando com projeto pequenos, tarefas como baby steps e feedback contínuo que eu chegue a um grau mais elevado de conhecimento no fim desse desafio, ou seja, a ideia é conseguir entrar muito melhor do que entrei. Meu desafio Para 2022 preciso dar um ponto em alguns projetos que abri e também quero lançar meu primeiro jogo na steam. Então dividi os dois primeiros meses no ano para organizar 2 projetos que já tenho aberto, ai os próximos 10 meses vão ser focados no desenvolvimento de jogos e esses jogos vão tanto me ajudar a trabalhar habilidades que uso no trabalho quanto habilidades pro meu jogo. Nesse ano vou focar em desenvolver pixel art e trabalhar com uma engine em rust pro meu jogo na qual vou compilar pra steam. Nesse desafio estou calculando investir 20 horas mensais de prática, que é o máximo que vou conseguir no momento. Estou inicialmente pensando em fazer alguns jogos no estilo de livro-jogo texto, pois são bem simples e da pra fazer tudo com apenas programação, sendo que imagens seriam um plus, mas dentro desse desafio não pretendo eu mesmo criar os fluxos da história pretendo pegar pronto de algum amigo que se interessar =-). Projetos ** Janeiro ** Projeto do template fastapi, vou montar um cli pra criar um projeto simples e a evolução do exemplo usando a sessão dos dados como injeção de dependência. Além disso transformar isso numa lib e publica-la no pypi. ** Fevereiro ** Projeto do fast-ecommerce criar uma documentação em monorepo, adicionar testes via github actions e atualizar dependências com o mínimo de refatoração. ** Março ** Criar um livro-jogo usando vue/ts e python/fastapi. ** Abril ** Criar um pixel art pro jogo de Março, a abertura do jogo e o encerramento. ** Maio ** Criar um livro-jogo usando vue/ts e rust/actix. ** Junho ** Criar em pixel art 10 diagramações do jogo do mês anterior fora a abertura e o encerramento. ** Julho ** Criar um livro-jogo usando uma engine de games em rust no momento a mais provavel é a bevy. ** Agosto ** Criar em pixel art 20 diagramações do jogo do mês anterior fora a abertura e o encerramento. ** Setembro ** Criar um jogo simples de plataforma usando apenas uma tela. ** Outubro ** Criar um jogo simples de plataforma com uma fase e power-ups ou fazer essa evolução no jogo do mês anterior. ** Novembro ** Criar um jogo simples de plataforma com duas fases e power-ups ou fazer essa evolução no jogo do mês anterior. ** Dezembro ** Criar um jogo simples de plataforma com quatro fases e power-ups ou fazer essa evolução no jogo do mês anterior. Além de publicar ele na steam. Todos os objetivos para cada projeto eu coloquei no mapa abaixo: Mapa de objetivos dos projetos Motivação A ideia é conseguir provar uma tese que venho estudando em vários livros e cursos, onde direcionando meu estudo exclusivamente para pratica deliberada e através de projetos pequenos, com feedback rápido, fail fast e uma prática metódica eu consiga me desenvolver mais rapidamente. E sim a ideia não é nem lançar curso e nem livro sobre aprendendo a aprender, mas sim tentar provar que com os conceitos que coloquei na minha postagem de regras vou conseguir aprender um conhecimento e fixa-lo mais rapidamente e assim conseguir ajudar outras pessoas com as postagens que eu for fazendo durante o 2022. Bom os planos e retrospectivas dos projetos vou publicando aqui e vou tentar sempre que possível compartilhar no twitch, bom é isso por enquanto e até 2022."},{"title":"Desafio de prática - Regras","description":"\"Regras pro desafio de prática\"","tags":[],"slug":"desafio-de-pra-tica-regras","html":"Projeto Precisa definir um período em meses ou anos Mapear o que quer aprender O plano precisa ser horas de prática estudos tem que ser a parte e não é necessário registrar Fazer cada projeto com duração máximo de 1 mês Escopo de projetos futuros pode ser corrigido Regras para cada projeto Desenhar um mapa (Por que? O que? Como?) Artigo antes do projeto com o escopo e o mapa Retrospectiva depois do projeto Precisa ser público As horas precisam ser de prática Cada projeto precisa ser quebrado em pequenas atividades Comemorar entrega do projeto Comomorar cada habilidade que foi aprendida Durante as sessões de prática Aspecto que quer melhorar Precisa ser especifico Registrar o dia-a-dia diário de bordo ** Ser específico ** Por o que quer melhorar ** Por detalhes que ache relevante Metas ambiciosas"},{"title":"Sintaxe literal vs Construtor em Rust","description":"\"As ferramentas que estou usando no meu workflow de trabalho\"","tags":[],"slug":"sintaxe-literal-vs-construtor-em-rust","html":"Essa é uma tradução livre deste artigo. Estrutura literal vs construtor em Rust Aprender o básico de uma linguagem e a sintaxe é fácil. Agora como dar sentido para todos aqueles bits pode ser um pouco mais difícil. Há uma rede de interseções de três funcionalidades do Rust que vejo pessoas usando, mas nunca vi escrito.Eu espliquei essa técnica para algumas pessoas em #rust-bennigers outro dia, pensei em escrever pra ajudar você também. Um pequeno review, se você tem uma struct em Rust como este: struct Point { x: i32, y: i32, } Você pode usar a 'sintaxe literal do struct' para criar uma nova instância do struct: let origin = Point { x: 0, y: 0 }; Normalmente, esta sintaxe somente funciona se você tem acessso a propriedade da struct e de seu membro pela regra de privacidade do Rust. mod foo { pub struct Point { x: i32, y: i32, } pub fn foo(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // isto é bom , já que estamos no mesmo módulo } } fn main() { let origin = foo::Point { x: 0, y: 0 }; // isto não é bom } Nós não podemos usar a sintaxe literal struct na função main por que x e y também não são publicos. Mas, dentro do mesmo módulo nós temos acesso, então funciona. Como podemos deixar main instanciar Point, se não podemos usar uma sintaxe literal? Bem, nossa função foo faz isto, então nós podemos expo-la. Seria mais conveniente se nós associarmos a uma função new. mod foo { pub struct Point { x: i32, y: i32, } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // Isto é bom, já que estamos no mesmo módulo } } } fn main() { let origin = foo::Point::new(0, 0); } Certo, mas se por alguma razão nós quiséssemos que x e y sejam públicos ou ainda se quiséssemos forçar as pessoas a criar uma função new para criar um Point? Talvez nossa mudança gere um efeito colateral importante. Então se trocarmos nosso código para isto: mod foo { pub struct Point { pub x: i32, pub y: i32, } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // isto é bom, já que estamos no mesmo módulo } } } fn main() { let origin = foo::Point::new(0, 0); // mas, isto também: let origin = foo::Point { x: 0, y: 0 }; } Fazendo todos os elementos de Point publicos, nós reativariamos a sintaxe literal, que não é o que gostariamos de chegar, então o que fazer? Pra corrigir isso precisamos de dois insights. O primeiro é &quot;zero-size types&quot;. No Rust tem alguns tipos que não requerem nenhum armazenamento. Vamos pegar o exemplo da tupla vazia '()', ele também só tem uma possibilidade de valor que é a própria tupla vazia. Assim nós não há necessidade de armazenar nada em memória pra representa-la. Se nós temos um valor válido, nós já saberemos o que ele é. Isso significa que quando a aplicação é compilada a tupla vazia () simplesmente desaparece, então podemos fazer isso. mod foo { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } } fn main() { let origin = foo::Point::new(0, 0); } Agora nós temos um novo atributo privado _secret(). Eu dei esse nome com o underscore '_', por que não temos intenção de usa-lo pra nada. Assim o Rust não vai nos dar nenhum warning pois como _secret é do tipo () e será gerado em tempo de compilação e não afetará nosso struct Point. Mas, tendo este atributo privado afeta a permissão que temos para contruir Point. main não pode usar a sintaxe literal de struct uma vez que nem todos os campos são públicos. No entanto lembre-se que privacidade é em nível de módulo em Rust, portanto ainda podemos usar a sintaxe literal dentro do módulo foo: mod foo { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } fn foo() -&gt; Point { Point: { x: 0, y: 0, _secret: () } // Isto ainda é permitido! } } fn main() { let origin = foo::Point::new(0, 0); } Para previnir que foo seja usado com sintaxe literal, nós precisamos de mais um conceito: pub use, veja isto: mod foo { mod point { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } } pub use foo::point::Point; fn foo() -&gt; Point { Point::new(0, 0) // Precisamos usar `new` aqui, Já que não estamos mais dentro do mesmo módulo! } } fn main() { let origin = foo::Point::new(0, 0); } Dando pra Point seu próprio módulo, tudo que é privado pra ele fica privado para quem o usa-lo também. Mas, escrevendo foo::point::Point fica verboso, ai pub use vem nos salvar! Nós re-exportamos a estrutura de Point em foo, então nós podemos ainda usar foo:Point, mas uma vez que um de seus membros é privado, a sintaxe literal não é permitida. Para mim, entender coisas como essa é quando eu realmente começo a sentir que estou conhecendo uma linguagem: juntando três ou quatro conceitos díspares para atingir algum objetivo. É quando uma linguagem deixa de ser um monte de partes desconexas e começa a se tornar um todo coeso."},{"title":"Mudando path do poetry","description":"\"Como configurar o poetry para mudar o diretório padrão que ele cria a Virtual Env\"","tags":[],"slug":"mudando-path-do-poetry","html":"Olá tudo bem? Estou passando aqui pra dar uma dica rápida, quando você possui muitos projetos em python as vezes fica difícil de gerenciar as Virtal Envs do projetos. Quando usava o pipenv isso não era tanto um problema, pois ele tinha um comando para remover uma virtualenv e recria-la novamente, porém o poetry até esse momento ainda não criou tal comando. Ai lembre do Renzo do Python Pro, falava que criava as envs diretamente no projeto numa pasta .env, então decidi fazer assim também no meu ambiente e vem me ajudando muito. Pra fazer isso é bem simples é só executar o comando abaixo no seu terminal: poetry config virtualenvs.in-project true Lembrando que pra funcionar você precisa ter o poetry instalado no seu pipenv =D Bom gente é isso, espero que lhe ajudem."},{"title":"Afiando o machado 2021","description":"\"As ferramentas que estou usando no meu workflow de trabalho\"","tags":[],"slug":"afiando-o-machado-2021","html":"Afiando o machado em 2021 Bom estamos começando mais um ano, deixando esse difícil ano de 2020 pra trás, então decidi no hiato entre 2020 e 2021 de revisar meu ambiente de desenvolvimento, então gostaria de compartilhar com vocês como está ficando. Pra começar é bom colocar as linguagens / frameworks que tenho configuradas no meu ambiente : Dart / Flutter Python / Flask / Django / FastAPI Javascript / Vue Rust Go Um ponto que acho interessante frisar que em 2021 vou ter um ano atípico no que diz a sistema operacional, vou começar o ano com o Mac, lá pelo meio do ano vou usar o Windows e no fim do ano devo voltar pro Linux, mais precisamente o Arch se não viu meu artigo anterior acesse aqui ali eu já fiz uma guia da minha instalação. Com isso meu ambiente de desenvolvimento tem que ser o mais flexível possível, além de tudo eu gosto de trabalhar no terminal então como vou usar o WSL2 no Windows (talvez até um virtualbox mesmo) vai ser mais tranquila essa transição. Legal já frisar que nesse artigo específico não vou explicar detalhadamente a configuração de cada ferramenta, pretendo fazer isso ao longo do ano, mas já queria falar quais ferramentas estou usando hoje. Outro ponto importante pra mim é eu gosto de experimentar uma coisa ou outra, mas sempre de forma separada do fluxo padrão, pois eu posso achar que um projeto ainda não está tão legal pra mim, simplesmente desistir ou ainda intrega-lo no meu workflow principal, removendo a ferramenta anterior, faço isso muito por curiosidade sobre o desenvolvimento de outras ferramentas e vez ou outra acabo incorporando uma ferramenta nova durante o ano ou mesmo um plugin. Algo pra entrar no meu workflow precisa me deixar mais produtivo e não o contrário. Pra facilitar a sua leitura deu dividi o artigo nos tópicos abaixo: Fontes Prompt de comando Emulador de terminal Multiplexador Python Dart / Flutter Vue Editor Docker Conclusão Fontes Uma coisa que pode não parecer muito importante, mas que no meu workflow eu acho super importante é o uso do nerdfonts, pois ele me dá um conjunto de fontes e ícones que vou colocar tanto no meu terminal, quanto no meu editor de texto, como eu fico 80% do meu tempo dentro do terminal ter boas fontes e bons ícones ajuda a deixar o ambiente mais agradável, sei que muita gente gosta e vive bem com um terminal mais &quot;seco&quot; e vive bem com isso. Além disso, eu pretendo usar também os ícones e fontes no próprio Xmonad. Tema Um tema que venho usando e gosto muito é o dracula, o bom dele é que basicamente posso usar o mesmo esquema de cores em todas as ferramentas que uso, inclusive no meu browser, então tudo que eu posso eu tento usar o drácula como tema. No caso do Xmonad ainda não tem um tema, mas pretendo resolver essa pendência =D. Prompt de comando Aqui eu uso o zsh como shell, para complementar uso o ohmyzsh pois ele me trás vários plugins úteis para o dia-a-dia e o starship para customizar a visualização do prompt pois ele possui várias opções de customizar a visualização e acho ele infinitamente mais leve que o tema do powerlevel10k que me dá várias opções mas, pelo menos no mac hoje fica bem pesado quando uso. Com isso já consigo usar autocomplete e ter alguns indícios visuais de um repositório, e no meu .zshrc eu vou colocando as configurações e alias de comando que mais uso no dia-a-dia. Uma coisa que penso em experimentar durante o ano é o fish shell e o elvish shell. Emulador de terminal Pode não parecer, mas minha ideia é ter o menor número de ferramentas / plugins dentro do meu workflow, pois é fácil você configurar algo e raramente usar. Porém no caso do emulador de terminal ainda tenho um dilema estou usando 2, o alacritty e o kitty. O alacritty é um emulador de terminal pequeno, leve e poderoso, ele segue o conceito dos emuladores com poucas features, o que é perfeito pra usar em tilling manager como o Xmonad ou o i3, porém hoje ele não tem uma feature que estou usando no momento, que é a compatibilidade para fontes com ligadura, tipo o fira code. Por conta disso estou usando o kitty, que é um emulador de terminal com muitos recursos, porém fora suas configurações básicas, não uso as features tmux like dele, muito por que acho que o próprio alacritty no futuro vai ter essa feature e eu devo voltar pra ele, e não me entenda mal o kitty é ótimo, mas muitas das features dele eu já resolvo com tmux + Xmonad, o que pode parecer estranho já que quero ter sempre o mínimo possível de ferramentas, mas durante esse ano se em algum momento eu achar que o Kitty está sendo mais vantajoso com certeza vou permanecer nele. Mas por enquanto a ideia é ter o alacritty como emulador de terminal principal. Multiplexador Aqui só tem uma ferramenta que uso que é o tmux, ele nada mais é que um multiplexador, trabalha com abas além de manipular as janelas de maneira muito parecida com o tilling manager, mas então por que usar isso até pelo que falei sobre o kitty? Uso principalmente por conta de gerar uma sessão e uma sessão básica, e o que isso quer dizer? Primeiro quando crio uma sessão no tmux, mesmo que feche o terminal a sessão ainda vai ficar de pé até que você reinicie o computador ou mate a sessão. Assim mesmo que acidentalmente feche o terminal a minha sessão vai continuar em pé normalmente. Agora outra feature que o tmux tem é poder criar templates de sessões, ou seja, já posso configurar quantidade de janelas, diretório que vai abrir além de dar start em alguma ferramenta como um git fetch ou coisa do tipo. Hoje uso apenas uma sessão e abro tudo que eu possa precisar, isso até por que hoje estou usando o mac e é mais conveniente abrir tudo já, porém quando voltar a usar o linux penso em criar sessões especializadas (editor, kubernetes, dart e etc), pois ao invés de ficar trabalhando com várias abas no tmux, posso trabalhar com uma apenas mas, com o workflow da atividade que vou trabalhar já. Voltando ao kitty ele faz isso também tanto em manter sessão quanto montar templates de uso, aqui a preferência é por já ter o costumo com os atalhos do tmux, conforme esse ano for passando talvez eu faça alguns testes usando só o kitty, por que talvez eu ganhe mais usando só ele ao invés do alacritty + tmux. Python Aqui nessa sessão eu configuro a versão do python e meu ambiente virtuais, primeira ferramenta que uso é o pyenv, no caso ele vai gerenciar a versão do python que estou usando em determinado projeto, por exemplo, hoje tenho projetos que usam python 3.5, 3.7 e 3.9, isso muito por que alguns projetos usam bibliotecas de terceiros que são incompatíveis com versões mais recentes do python. Além disso o pyenv me dá a possibildade de não &quot;sujar&quot; a versão do python do sistema (mac/linux), pois essa versão vai ser usada para as aplicações do sistema, e prefiro deixar ela intocada, isso é interessante se você algum dia já instalou várias bibliotecas no seu python de sistema e um aplicativo já parou de funcionar por conflito, tendo a versão do python segregada te ajuda a resolver esse problema, além disso o pyenv você consegue configurar na sua versão global todas as versões que vc está usando. O pyenv tem plugins para gerenciar suas virtuals envs, porém hoje eu prefiro usar o poetry, ele ajudar a manter o controle das bibliotecas que uso em determinado projeto, mantém uma árvore de dependências, versionando inclusive lib dependentes do meu projeto além de criar minha virtualenv tudo com um comando, e isso é uma das coisas que mais gosto dele. Dart / Flutter Aqui não tem muito segredo, pois eu simplesmente uso o procedimento do site do flutter pra fazer a instalação, como não mexo tanto no dart/flutter (esse ano devo usar mais), então a configuração padrão já me atende sem muito problema. Aqui talvez num futuro se precisar trabalhar com versões diferentes do dart uma solução seria usar o [asdf] (https://github.com/asdf-vm/asdf), mas ainda não sei se seria necessário. Vue Para trabalhar com vue eu preciso de duas coisas, primeiro o NVM com ele eu consigo usar a versão do Node que eu quiser para determinado projeto de forma fácil e rápida, é um processo bem parecido com o pyenv, a segunda coisa que preciso é o VueCLI que já ajuda a criar os projetos VUE de forma bem rápida, além de subir um plugins pré configurados. Editor Já usei vários editores na vida, mas nos últimos anos tenho dado preferência ao vim e mais especificamente ao NeoVim, muito por que mesmo tendo vários plugins nele ainda é bem leve para se trabalhar. O NeoVim quando instalado já possui várias configurações interessantes, das quais pretendo colocar em outro post que já ajuda bastante, mas gostaria de falar aqui dos principais plugins que uso hoje. Para ter um intellisense e alguns auto formats eu uso o COC ele já me da uma gama de possibilidades de configurar o interpretador para python, js, vue e dart e sem muito esforço, sua única inconveniência ao meu ver é ter que criar uma pasta de configuração .vim em todos os projetos que trabalho. Com ajuda do COC eu também configuro a parte do cTags para poder funcionar os Go To na navegação do código. NerdTree eu uso para poder navegar nos diretórios do projeto e poder alterar, adicionar e remover pastas e diretórios é bem fácil de usar e bem funcional. FZF, CTRLP e o FERRET, são um conjunto de plugins para fazer busca tanto no diretório quanto detro dos arquivos junto com o RG e o AG para aplicar os algoritmos de busca o que otimiza o tempo para fazer as buscas. Com isso já consigo fazer buscas rápidas pelo meu código. VIM-FUGITIVE pra mim um dos melhores plugins para dominar no vim, com ele eu consigo trabalhar e ir fazendo meus commits, pulls, pushs sem precisar ter uma outra janela do terminal pra ficar fazendo isso, o que acaba facilitando muito a vida, além de conseguir fazer um gitdiff quando em pull acontece algum conflito com minhas alterações. Bom poderia falar de muitos outros plugins que uso mas, acredito que hoje esses são os mais essenciais pro meu dia-a-dia de trabalho. Docker Aqui também uso as instalações padrões do docker e docker-compose, além de muitas vezes ainda não desenvolver diretamente no docker, todas as estruturas de apoio para o desenvolvimento como db, filas, ferramentas de monitoração e etc, eu rodo no docker, e também quando preciso simular algum problema que não ocorre quando subo o projeto diretamente no poetry eu acabo apelando pra subir o projeto via docker-compose e ver se consigo replicar o erro. Penso que quando você começa a trabalhar com docker, você vai sentir dificuldade de deixar ele, pois ele ajuda muito a deixar as configs do seu sistema limpas, pois todas as bibliotecas, instalações e afins estão contidas dentro do container. Conclusão A ideia aqui foi apresentar o conjunto de ferramentas que uso no meu workflow de trabalho no dia-a-dia, aqui além de talvez você me falar que instalando o pacote do jetbrains eu teria quase tudo isso já na mão. Mas, como sempre digo a melhor ferramenta é a que você se sente mais produtivo, acredito que o meu workflow tem uma produtividade bem alta e com um baixo custo de recursos (vendo que tenho um mac de 2014 e um notebook que é um core 2 duo com 4gb de ram), além disso ter um workflow via terminal é extremamente poderoso pois faço praticamente tudo que preciso apenas usando alguns comandos ou atalhos no teclado. Acredito que no caso de um workflow como o meu tem um grande trabalho em &quot;esculpir&quot; as configurações, porém ele fica exatamente do jeito que você quer ao contrário de um jetbrains ou mesmo o vscode que você acaba ficando preso a algumas definições da ferramenta. Enfim, espero que você goste e convido a compartilhar ferramentas que você ache legal pra trabalhar num workflow usando terminal ou algum outro workflow que você use, gosto muito de conhecer outros workflows de trabalho =). Então é isso e até o próximo artigo."},{"title":"Minha instalação do Arch Linux","description":"\"Um roteiro de como eu instalo o Arch Linux\"","tags":[],"slug":"minha-instalac-a-o-do-arch-linux","html":"Instalação do Arch Linux Bom começando 2021 com um blog novo decidi compartilhar o meu roteiro para instalar o Arch Linux com algumas explicações. No longínquo ano de 2004 eu brincava com instalações complicadas como o FreeBSD, Gentoo e o Slackware, foi uma boa base para aprender muito, com todos os kernel panics da vida, mas minha vida com o pinguim naquela época ainda era só uma curiosidade, pois trabalhava com Delphi e ambiente Windows além de que nessa época era bem complicado jogar no Linux. Desde de 2014 voltei a trabalhar usando Linux inicialmente como freelance e depois na minha ocupação principal, um pouco isso se deve ao trabalho do Dionatan do Diolinux, mas desde então conhecim uma distro que não havia conhecido lá no começo dos anos 2000 que era o Arch linux, gostei muito da ideia do Pacman que é muito parecido com o Brew do MacOs, mas mesmo assim sempre fiquei nas distros ubuntu like pois era um sistema que eu tinha mais familiaridade. Esse ano de 2021 vai ser um ano atipico pra mim eu nesse momento estou usando um Mac, mas no meio do ano vou trabalhar alguns meses numa estação Windows até que mais pro final do ano estou pensando em pegar um notebook da System76, então no perído entre festas ali de 2020 eu decidi me aventurar em fazer uma instalação do Arch numa virtualbox para ter um roteiro pronto pra usar no meio do ano pra voltar a usar o Arch. Um ponto importante é que lá por 2017 eu comecei a usar o xubuntu com o gerenciador de janelas i3, antes de começar a usar o mac estava usando o Xmonad nesse guia eu levo em consideração a instalação do Xmonad pois já tenho meus arquivos de configuração que basicamente devo copiar, caso tenha interesse você pode ver no meu GitHub. Um disclamer antes do guia, na verdade eu achei a configuração do Arch relativamente tranquila, a documentação oficial, além de que pra mim me enrolei em alguns pontos que não estão muitos explicitos ali, então por isso fiz esse guia, dois vídeos que me ajudaram muito foi esse do Diolinux e essa do Derek Taylor, que alias também tem materiais muitos bons. Verificando UEFI Mode Verificar o bootmode se o comando abaixo der erro é por que está no UEFI mode Pode ser que essa pasta não exista ai o computador não tem suporte a UEFI ls /sys/firmware/efi/efivars Gerando o particionamento Aqui acredito que é algo bem pessoal, cada um organiza do jeito que acha melhor eu particularmente uso um / /boot /home /swap usando uma estrutura de partições GPT, caso você não saiba o que é de uma olhada nesse artigo do sempreupdate. Particionar o disco fdisk -l #lista discos fdisk /dev/sda # ou o disco que vc quer particionar exemplo de criação com comandos para o /boot - n - 1 - 2048 - +200M # Pra criar uma partição existente como swap - t - 2 # numero da partição - 19 # Código do swap # Bootloader - t - 1 - 1 # EFI Filesystem ou 4 bios boot se for MBR Agora precisamos formatar as partições pra isso usamos o mkfs e no caso do swap usamos o mkwap e swapon. Formatar partições mkfs.ext4 /dev/sda1 # Swap mkswap /dev/sda2 swapon /dev/sda2 Instalar dostools pacman -S dosfstools Formatar a partição do boot mkfs.fat -F 32 /dev/sda1 # Pode ser BIOS boot ou EFI que é a opção 1 Montando os filesystems Bom o próximo passo é montar o filesystem para fazer a instalação além de montar os diretórios que vão ficar separados em partições diferentes como o /boot e o /home. Acho bom enfatizar que o nome das partições vai variar dependendo de como você particionou, no meu caso vai ser /dev/sda1 /dev/sda2 /dev/sda3 e /dev/sda4, porém abaixo deixei da forma mais genérica. Montar o filesystem mount /dev/root_partition /mnt Criar pastas de boot e home mkdir /mnt/home mkdir /mnt/boot/ # caso EFI tem que ser /mnt/boot/EFI Montar o filesystem mount /dev/mount-boot /mnt/boot mount /dev/mount-home /mnt/home Instalação Bom agora chegou a hora da instalação, como você vai ver é bem simples: instalar os pacotes básicos pacstrap /mnt base base-devel linux linux-firmware Agora vamos gerar o fstab, se não sabe o que é o fstab da uma conferida nesse vídeo do Diolinux. Gerar o fstab genfstab -U /mnt &gt;&gt; /mnt/etc/fstab Agora vamos montar o root do arch linux. Mudar a montagem pra root arch-chroot /mnt Setar hora local ln -sf /usr/share/zoneinfo/America/Sao_Paulo /etc/localtime hwclock --systohc Instalar o neovim ou editor da sua preferência. pacman -Sy neovim Editar o arquivo /etc/locale.gen e descomentar o en-UTF8 ou a lingua que você usa como pt_BR-UTF8 # depois gerar os arquivos locale-gen Criar arquivo /etc/locale.conf e add a linguagem padrão do sistema LANG=en_US.UTF-8 Hostname Add o hostname em /etc/hostname Editar o /etc/hosts /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname.localdomain myhostname Gestão do USER Definir senha do root passwd Add user useradd -m -g users -G wheel,audio,video,storage nome_desejado_para_o_usuario Add no /etc/sudoers myuser ALL=(ALL) ALL Atualizar agora o usuário que eu criei com o passwd. passwd nome_desejado_para_o_usuario Pacotes adicionais Instalar pacotes adicionais (pra wifi continuar funcionando no pos instalação) pacman -S dosfstools os-prober mtools network-manager-applet networkmanager wpa_supplicant wireless_tools dialog sudo Grub Acho que foi a parte que mais me enrosquei, importante que precisa já ter criado e formatado, além disso aqui é importante que ele usa pacotes diferentes dependendo do tipo da sua partição do boot. Instalar o GRUB pacman -S grub os-prober # MBR grub-install --target=i386-pc --recheck /dev/sda # EFI pacman -S efibootmgr grub-install --target=x86_64-efi --bootloader-id=grub_uefi --recheck CONFIG grub-mkconfig -o /boot/grub/grub.cfg Pós Instalação Primeiro vou habilitar o networkmanager pois senão não vai habilitar a rede. Hábilitar o network manager systemctl enable NetworkManager Depois disso reinicio e testo através de um ping se está funcionando a rede além é claro de logar com o meu usuário, agora pra usar o pacman vamos usar o sudo. Instalar o básico pra usar o Xmonad e algumas aplicações sudo pacman -Syy xorg xorg-xinit xf86-video-fbdev(ou sua placa de video) nitrogen picom firefox neovim ranger rxvt-unicode sudo pacman -Syy lightdm lightdm-gtk-greeter xmonad xmonad-contrib xmobar dmenu kitty Ali instalo dois terminais o urxvt e o kitty, isso acontece pois quando fiz a instalação tive problemas com o kitty no inicio da configuração, então uso o urxvt e depois de copiar todas as minhas configs eu mudo para o kitty, já que o caração de usar um tilling manager é ter acesso fácil ao terminal. Configurar o .xinitrc copiando o exemplo do xorg pra sua home cp /etc/X11/xinit/xinitrc .xinitrc Adicionar o arquivo o start do nitrogen do picom e do xmonad # Remover twm &amp; ... exec xterm -geometry 80x66+0+0 -name login #Adicionar exec xmonad Bom com essa configuração eu já consigo iniciar o Xmonad, eu gosto de deixar ele funcional já por que se houver algum problema pra subir o Xorg ou o Xmonad ele ainda vai entrar em modo texto. Testar a inicialização startx Bom agora aqui eu copio meus arquivos de configuração, se você não tem os seus pode usar o meu clicando aqui. Copiar os arquivos de configuração do xmonad e do xmobar # criar diretório .xmonad # criar diretório .config/xmobar Normalmente eu reinicio logo novamente e dou um startx só pra ter certeza que tudo está funcionando, ai sim eu habilito o lightdm pra iniciar tudo já no modo gráfico. Habilitar o lightdm sudo systemctl enable lightdm Depois disso, eu começo a configurar o meu ambiente de desenvolvimento mas, o sistema já está pronto pra ser usado. Caso tenham alguma dúvida pode colocar nos comentários que ajudo da melhor maneira que conseguir."},{"title":"Sobre","description":null,"tags":[],"slug":"about","html":"Olá sou o Jônatas tudo bem? Sou desenvolvedor fullstack, usando python, rust, vue e svelte. Estou aprendendo a desenvolver jogos em rust também."}]