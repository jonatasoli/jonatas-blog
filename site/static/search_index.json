[{"title":"Welcome to Marmite","description":null,"tags":[],"slug":"welcome","html":"This is your first post! Edit this content edit on content/{date}-welcome.md Add more content create new markdown files in the content folder use marmite --new to create new content Customize your site edit marmite.yaml to change site settings edit the files starting with _ in the content folder to change the layout or edit the templates to create a custom layout Deploy your site read more on marmite documentation"},{"title":"Sintaxe literal vs Construtor em Rust","description":null,"tags":[],"slug":"sintaxe-literal-vs-construtor-em-rust","html":"Essa é uma tradução livre deste artigo. Estrutura literal vs construtor em Rust Aprender o básico de uma linguagem e a sintaxe é fácil. Agora como dar sentido para todos aqueles bits pode ser um pouco mais difícil. Há uma rede de interseções de três funcionalidades do Rust que vejo pessoas usando, mas nunca vi escrito.Eu espliquei essa técnica para algumas pessoas em #rust-bennigers outro dia, pensei em escrever pra ajudar você também. Um pequeno review, se você tem uma struct em Rust como este: struct Point { x: i32, y: i32, } Você pode usar a 'sintaxe literal do struct' para criar uma nova instância do struct: let origin = Point { x: 0, y: 0 }; Normalmente, esta sintaxe somente funciona se você tem acessso a propriedade da struct e de seu membro pela regra de privacidade do Rust. mod foo { pub struct Point { x: i32, y: i32, } pub fn foo(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // isto é bom , já que estamos no mesmo módulo } } fn main() { let origin = foo::Point { x: 0, y: 0 }; // isto não é bom } Nós não podemos usar a sintaxe literal struct na função main por que x e y também não são publicos. Mas, dentro do mesmo módulo nós temos acesso, então funciona. Como podemos deixar main instanciar Point, se não podemos usar uma sintaxe literal? Bem, nossa função foo faz isto, então nós podemos expo-la. Seria mais conveniente se nós associarmos a uma função new. mod foo { pub struct Point { x: i32, y: i32, } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // Isto é bom, já que estamos no mesmo módulo } } } fn main() { let origin = foo::Point::new(0, 0); } Certo, mas se por alguma razão nós quiséssemos que x e y sejam públicos ou ainda se quiséssemos forçar as pessoas a criar uma função new para criar um Point? Talvez nossa mudança gere um efeito colateral importante. Então se trocarmos nosso código para isto: mod foo { pub struct Point { pub x: i32, pub y: i32, } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y } // isto é bom, já que estamos no mesmo módulo } } } fn main() { let origin = foo::Point::new(0, 0); // mas, isto também: let origin = foo::Point { x: 0, y: 0 }; } Fazendo todos os elementos de Point publicos, nós reativariamos a sintaxe literal, que não é o que gostariamos de chegar, então o que fazer? Pra corrigir isso precisamos de dois insights. O primeiro é &quot;zero-size types&quot;. No Rust tem alguns tipos que não requerem nenhum armazenamento. Vamos pegar o exemplo da tupla vazia '()', ele também só tem uma possibilidade de valor que é a própria tupla vazia. Assim nós não há necessidade de armazenar nada em memória pra representa-la. Se nós temos um valor válido, nós já saberemos o que ele é. Isso significa que quando a aplicação é compilada a tupla vazia () simplesmente desaparece, então podemos fazer isso. mod foo { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } } fn main() { let origin = foo::Point::new(0, 0); } Agora nós temos um novo atributo privado _secret(). Eu dei esse nome com o underscore '_', por que não temos intenção de usa-lo pra nada. Assim o Rust não vai nos dar nenhum warning pois como _secret é do tipo () e será gerado em tempo de compilação e não afetará nosso struct Point. Mas, tendo este atributo privado afeta a permissão que temos para contruir Point. main não pode usar a sintaxe literal de struct uma vez que nem todos os campos são públicos. No entanto lembre-se que privacidade é em nível de módulo em Rust, portanto ainda podemos usar a sintaxe literal dentro do módulo foo: mod foo { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } fn foo() -&gt; Point { Point: { x: 0, y: 0, _secret: () } // Isto ainda é permitido! } } fn main() { let origin = foo::Point::new(0, 0); } Para previnir que foo seja usado com sintaxe literal, nós precisamos de mais um conceito: pub use, veja isto: mod foo { mod point { pub struct Point { pub x: i32, pub y: i32, _secret: (), } impl Point { pub fn new(x: i32, y: i32) -&gt; Point { Point { x: x, y: y, _secret: () } } } } pub use foo::point::Point; fn foo() -&gt; Point { Point::new(0, 0) // Precisamos usar `new` aqui, Já que não estamos mais dentro do mesmo módulo! } } fn main() { let origin = foo::Point::new(0, 0); } Dando pra Point seu próprio módulo, tudo que é privado pra ele fica privado para quem o usa-lo também. Mas, escrevendo foo::point::Point fica verboso, ai pub use vem nos salvar! Nós re-exportamos a estrutura de Point em foo, então nós podemos ainda usar foo:Point, mas uma vez que um de seus membros é privado, a sintaxe literal não é permitida. Para mim, entender coisas como essa é quando eu realmente começo a sentir que estou conhecendo uma linguagem: juntando três ou quatro conceitos díspares para atingir algum objetivo. É quando uma linguagem deixa de ser um monte de partes desconexas e começa a se tornar um todo coeso."},{"title":"Rust Descomplicado: Desvendando os mistérios dos tipos básicos","description":null,"tags":[],"slug":"rust-descomplicado-desvendando-os-miste-rios-dos-tipos-ba-sicos","html":"Rust Descomplicado: Desvendando os Mistérios dos Tipos Básicos Olá tudo bem? Hoje quero falar com você sobre os tipos primitivos em rust. Tipos primitivos são em linguagens de programação como Rust, são os tipos básicos de dados que são fornecidos pela linguagem e não são construídos a partir de outros tipos. Cada tipo tem um tamanho determinado para armazenar suas informações e a partir desses tipos básicos o rust consegue criar os outros tipos que ele usa, e claro você também pode criar seus próprios tipos. Mas, sem enrolação vamos ao video. Inteiros (Integers) O primeiro tipo que vamos falar são os tipos inteiros, e sim no plural pois temos vários tipos inteiros. Os números inteiros são divididos em dois grupos os números inteiros com sinal também chamados de Signed (representa positivos, negativos e zero) e os números inteiros sem sinal também chamados de Unsigned (Representa positivos e zero). Para os inteiros Signed temos: i8: 8 bits que varia entre -128 a 127. i16: 16 bits que varia entre -32,768 a 32,767 i32: 32 bits que varia entre -2,147,483,648 a 2,147,483,647 i64: 64 bits que varia entre -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807. i128: 128 bits que varia entre -170,141,183,460,469,231,731,687,303,715,884,105,728 a 170,141,183,460,469,231,731,687,303,715,884,105,727. fn main() { // i8 let number_i8: i8 = -128; println!(&quot;i8: {}&quot;, number_i8); // i16 let number_i16: i16 = -32768; println!(&quot;i16: {}&quot;, number_i16); // i32 let number_i32: i32 = -2147483648; println!(&quot;i32: {}&quot;, number_i32); // i64 let number_i64: i64 = -9223372036854775808; println!(&quot;i64: {}&quot;, number_i64); // i128 let number_i128: i128 = -170141183460469231731687303715884105728; println!(&quot;i128: {}&quot;, number_i128); } Para os interior Unsigned temos: u8: 8 bits que varia entre 0 a 255. u16: 16 bits que varia entre 0 a 65,535. u32: 32 bits que varia entre 0 a 4,294,967,295. u64: 64 bits que varia entre 0 a 18,446,744,073,709,551,615. u128: 128 bits que varia entre 0 a 340,282,366,920,938,463,463,374,607,431,768,211,455. fn main() { // u8 let number_u8: u8 = 255; println!(&quot;u8: {}&quot;, number_u8); // u16 let number_u16: u16 = 65535; println!(&quot;u16: {}&quot;, number_u16); // u32 let number_u32: u32 = 4294967295; println!(&quot;u32: {}&quot;, number_u32); // u64 let number_u64: u64 = 18446744073709551615; println!(&quot;u64: {}&quot;, number_u64); // u128 let number_u128: u128 = 340282366920938463463374607431768211455; println!(&quot;u128: {}&quot;, number_u128); } Fora isso temos o tipo usize e isize que representam palavras no formato do processador que está sendo usado ou seja 32 bits pra processadores de 32 bits e 64 bits para processadores de 64 bits. O uso de isize é útil quando você está lidando com índices de coleções ou quando deseja garantir que seu código seja eficiente em diferentes arquiteturas sem ter que se preocupar com o tamanho exato do inteiro. Suponha que você queira imprimir o tamanho de um vetor em termos de número de elementos, e para isso, você pode usar o tipo isize para garantir portabilidade. Aqui está um exemplo: rust fn main() { let vetor = vec![1, 2, 3, 4, 5]; // Usando .len() para obter o tamanho do vetor, que retorna um usize. // Convertendo para isize para impressão e operações posteriores. let tamanho: isize = vetor.len() as isize; println!(&quot;O tamanho do vetor é: {}&quot;, tamanho); // Aqui, apenas para ilustrar, vamos fazer uma operação simples. let novo_tamanho = tamanho + 10; println!(&quot;Se adicionar 10, o novo tamanho é: {}&quot;, novo_tamanho); } Neste exemplo, usamos isize para representar o tamanho do vetor. Ao fazer isso, garantimos que o código funcione tanto em arquiteturas de 32 bits quanto de 64 bits, adaptando-se automaticamente ao tamanho da palavra do sistema. Um parenteses: Os termos &quot;32 bits&quot; e &quot;64 bits&quot; referem-se ao tamanho da palavra de um processador, o que, por sua vez, influencia o tamanho máximo de dados que o processador pode processar em uma única operação e a quantidade máxima de memória RAM que o sistema operacional pode endereçar. Ponto Flutuante (Floating-Point) Para pontos flutuantes vamos ter: f32: Ponto flutuante de precisão simples (32 bits). f64: Ponto flutuante de precisão dupla (64 bits). É o padrão para números decimais em Rust. Em computação, os termos &quot;precisão simples&quot; e &quot;precisão dupla&quot; referem-se ao número de bits usados para representar números de ponto flutuante em um computador. No contexto do Rust e da maioria das linguagens de programação, esses termos são geralmente associados aos tipos f32 e f64, respectivamente. Precisão Simples (f32): Utiliza 32 bits para representar um número de ponto flutuante. Oferece uma precisão de aproximadamente 7 dígitos decimais significativos. É mais eficiente em termos de uso de memória e pode ser mais rápido em algumas operações devido ao tamanho menor. fn main() { // Exemplo com f32 let numero_f32: f32 = 3.14159; // Aproximadamente Pi println!(&quot;Valor usando f32: {}&quot;, numero_f32); // Outro exemplo com f32 let outro_f32: f32 = 123.456789; // Aproximadamente 123.456789 println!(&quot;Outro valor usando f32: {}&quot;, outro_f32); } Precisão Dupla (f64): Utiliza 64 bits para representar um número de ponto flutuante. Oferece uma precisão muito maior, aproximadamente 15 a 17 dígitos decimais significativos. Por ser mais preciso, é geralmente preferido em aplicações que exigem alta precisão, como cálculos científicos ou financeiros que envolvem números muito grandes ou muito pequenos, ou quando se deseja evitar erros acumulados em cálculos longos. fn main() { // Exemplo com f64 let numero_f64: f64 = 3.141592653589793; // Valor mais preciso de Pi println!(&quot;Valor usando f64: {}&quot;, numero_f64); // Outro exemplo com f64 let outro_f64: f64 = 123456789.987654321; // Número grande com precisão dupla println!(&quot;Outro valor usando f64: {}&quot;, outro_f64); } Caractere (Character) Para representar um caractere temos o tipo char e é usado para representar 1 caractere. Temos os tipos str e String mas, eles são usados para representar um grupo de caracteres o tipo primitivo é apenas o char. O char armazena 4 bytes e é usado para representar um caractere Unicode. fn main() { let letra = 'A'; println!(&quot;Essa é a letra: {}&quot;, letra); } E o que é Unicode? Unicode é um padrão de codificação de caracteres universal que visa definir um único código numérico para cada caractere de qualquer sistema de escrita do mundo. A ideia por trás do Unicode é criar uma forma de representação padronizada para caracteres de todos os idiomas e símbolos usados globalmente. Um exemplo armazenando o kanji Megami do japones: fn main() { let megane = 'u{76EE}'; println!(&quot;{}&quot;, megane); } Um exemplo armazenando um emoji: fn main() { let emoji_sorriso = 'u{1F603}'; println!(&quot;{}&quot;, emoji_sorriso); } Booleano (Boolean) O tipo booleano é usado para presentar como o nome já diz um valor booleano. Sendo true para verdadeiro e false para falso. fn main() { let verdadeiro = true; let falso = false; println!(&quot;Verdadeiro -&gt; {}, Falso -&gt; {}&quot;, verdadeiro, falso) } Bom o post de hoje é isso nos vemos na próxima semana."},{"title":"Por que eu abandonei o desafio de 12 meses?","description":null,"tags":[],"slug":"por-que-eu-abandonei-o-desafio-de-12-meses","html":"O desafio No começo de 2022 eu me propus a fazer um desafio de prática deliberada durante 12 meses com o objetivo de fazer vários pequenos projetos nesse periodo e no final eu queria conseguir lançar meu primeiro jogo na steam. No começo estava tudo bem, fiz o primeiro projeto em janeiro, porém mesmo ele, acabei mudando muito o escopo durante o processo. Pois eu queria refatorar um template de fastapi para ter mais opções e tal, depois pensei em focar em fazer um cli e acabou virando uma pr para o projeto do fastapi, que no final nem foi aceito pois a comunidade me convenceu que fazer um cli oficial não faria sentido e até achei uma solução mais simples usando o make. Enfim, eu deveria ter feito uma retrospectiva mais detalhada, mas eu não a fiz por que fiquei chateado com a pr, o problema foi um pouco mais embaixo. Cavando esse buraco Durante esse trabalho eu tinha me proposto fazer duas horas por dia entre as 20 e as 22 pois normalmente meu filho estaria dormindo e ficaria tudo bem. O que foi bem durante as primeiras semanas, só que comecei a ter algumas dificuldades. O tempo que estava separado pra isso foi sendo consumido por muitas outras atividades, pior que em tese eu sabia que precisava fazer essas atividades, só estava talvez me enganando um pouco. Fui fazendo as lives, e foram acontecendo problemas, uma hora doente, outra o bebe chora, outra tem que limpar a casa, outra preparar as refeições e quando vejo estou exausto e me arrastando por ai. Nem tudo funciona como planejado Primeira dificuldade foi que peguei covid, cheguei até fazer algumas lives do desafio com covid sem saber mas, depois do covid fiquei bem cansado por um tempo, com isso o agravante que toda a familia também pegou, acabei necessitando investir um tempo ficando com minha familia cuidando deles. Segundo ponto foi meu esgotamento por conta do trabalho, entrei numa situação do trabalho onde algumas decisões acabaram me desgastando e me deixando exausto. Chegou um ponto que muitas vezes ia por meu filho pra dormir e acabava dormindo junto com ele, outras vezes eu ia conseguia apenas fazer os trabalhos domesticos e já não aguentava mais ficar acordado. Esse stress estava (ainda está) me consumindo muito. Ultimo ponto que vem me trazendo dificuldades é que hoje estou sem um escritório, na verdade sem nenhuma casa. Ano passado fui pra casa da minha sogra ficar um tempo lá e nesse momento estou na casa da minha mãe, no futuro devo estar indo pra uma casa fixa na alemanha, o que me leva a pensar que posso ter problema pra fazer lives por conta do fuso horario. Mudanças e compromisso Esse post não é pra ficar justificando com os problemas, já que cada um tem seus problemas e acredito que muita gente que fixa compromisso ou faz lives periodicamente tem seus problemas. Mas, queria deixar tambem algumas reflexões que tive durante esse período: Muitas atividades: Além do meu trabalho, tenho a responsabilidade de fazer atividades domésticas, ficar com meu filho, ficar com minha esposa, estudar inglês, estudar sobre autismo e além disso preciso reservar um tempo de fazer algo só pra mim. Muito abrangente: Fora os meus estudos de algoritmos, eu quero estudar rust e lua, design de jogos, pixelart, front frameworks e etc eu vejo que preciso direcionar mais os estudos por conta do tempo. Com isso tenho a conclusão que não consigo fazer de seg a sex 2 horas por dia de estudo focado, na verdade não consigo todos os dias e nem duas horas. Além disso nesse momento desisti um pouco da ideia de tentar fazer lives periódicas pelo simples fato que não tenho hoje um ambiente minimo pra fazer uma live e o tempo, pra quem viu algumas das minhas lives eu algumas vezes tinha que sair pra ver meu filho chorando já que ele ainda tem dificuldade de dormir sozinho e isso acaba atrapalhando a live em si, pra isso vou esperar realmente ter um momento oportuno pra voltar. Está tudo perdido entâo? Bom acredito em algo que minha esposa me fiz &quot;Quem quer da um jeito!&quot;, com isso sei que tenho problemas em manter a periodicidade relacionada aos dias, porém consigo usar um ciclo de estudos espaçado. Como funciona? Bom vou escolhar por exemplo três assuntos (python, autismo e inglês), monto um plano de estudo pros 3 assuntos onde cada ciclo tenha entre 20 e 30 min, com isso estudo 30 min de python, se tiver tempo vou pra próxima e assim por diante. Pode ser que faça um assunto em um dia, depois no dia seguinte faça os 3, no outro não faço nada, no outro faço dois ciclos. A ideia é ter menos projetos e mantendo eles pequenos (alguns não muito), além de tentar ir equilibrando os pratos da vida. Meu plano Bom já tenho 3 projetos de software, estou preparando um curso, tenho os desafios de aprender o basico de programação usando jogos e o rpg-api, tenho estudos de autismo, estudo do inglês além disso tenho minhas leituras (que não deixam de ser técnicas), o ponto é que vou diminuir bem o ritmo e não vou me comprometer com a twitch por enquanto. Vou tentar usar o mastodon pra ser meu diário de desenvolvimento, mostrando meus pequenos avanços e tentar primeiro focar no curso, quando terminar ele vou focar nos desafio e por ultimo vou focar nas apis. O ponto é por mais que queira produzir muito sobre desenvolvimento e ser altamente comprometido com minhas metas, quando se tem outras pessoas dependendo de você a coisa fica mais complicada, e nem falo do meu caso, penso em tanta gente em situações muito mais complicadas que eu e fazem um esforço herculeo pra conseguir aprender algo pra melhorar a vida da sua familia. Meu caso sei que posso ajudar muita gente, mas digamos há muitas outras pessoas que conseguem fazer o que eu quero fazer e melhor, minha prioridade sempre vai ser minha familia, se esse projeto atrapalhar a dinamica familiar é por que não vale ser trabalhado no momento. Conclusão Além de tudo a mensagem que queria passar é positiva, tente dar um jeito nos seus planos as vezes vale sim congelar ele, as vezes diminuir o ritmo só não perca eles pelo caminho se você realmente quer algo, estou praticamente a 3 anos num ensaio de começar a fazer jogos que é um sonho que tinha quando entrei na faculdade, sei que sou capaz e vou conseguir, mas sei que hoje com meus 34 anos, casado e um filho autista que eu preciso ser o melhor pai/esposo quanto eu conseguir. Isso não quer dizer abandonar tudo, mas achar um ponto de equilibrio onde consiga tocar os projetos pessoais e também cuidar da minha familia e das minhas responsabilidades. Enquanto isso continuamos a nadar!"},{"title":"Mudando path do poetry","description":null,"tags":[],"slug":"mudando-path-do-poetry","html":"Olá tudo bem? Estou passando aqui pra dar uma dica rápida, quando você possui muitos projetos em python as vezes fica difícil de gerenciar as Virtal Envs do projetos. Quando usava o pipenv isso não era tanto um problema, pois ele tinha um comando para remover uma virtualenv e recria-la novamente, porém o poetry até esse momento ainda não criou tal comando. Ai lembre do Renzo do Python Pro, falava que criava as envs diretamente no projeto numa pasta .env, então decidi fazer assim também no meu ambiente e vem me ajudando muito. Pra fazer isso é bem simples é só executar o comando abaixo no seu terminal: poetry config virtualenvs.in-project true Lembrando que pra funcionar você precisa ter o poetry instalado no seu pipenv =D Bom gente é isso, espero que lhe ajudem."},{"title":"Minha instalação do Arch Linux","description":null,"tags":[],"slug":"minha-instalac-a-o-do-arch-linux","html":"Instalação do Arch Linux Bom começando 2021 com um blog novo decidi compartilhar o meu roteiro para instalar o Arch Linux com algumas explicações. No longínquo ano de 2004 eu brincava com instalações complicadas como o FreeBSD, Gentoo e o Slackware, foi uma boa base para aprender muito, com todos os kernel panics da vida, mas minha vida com o pinguim naquela época ainda era só uma curiosidade, pois trabalhava com Delphi e ambiente Windows além de que nessa época era bem complicado jogar no Linux. Desde de 2014 voltei a trabalhar usando Linux inicialmente como freelance e depois na minha ocupação principal, um pouco isso se deve ao trabalho do Dionatan do Diolinux, mas desde então conhecim uma distro que não havia conhecido lá no começo dos anos 2000 que era o Arch linux, gostei muito da ideia do Pacman que é muito parecido com o Brew do MacOs, mas mesmo assim sempre fiquei nas distros ubuntu like pois era um sistema que eu tinha mais familiaridade. Esse ano de 2021 vai ser um ano atipico pra mim eu nesse momento estou usando um Mac, mas no meio do ano vou trabalhar alguns meses numa estação Windows até que mais pro final do ano estou pensando em pegar um notebook da System76, então no perído entre festas ali de 2020 eu decidi me aventurar em fazer uma instalação do Arch numa virtualbox para ter um roteiro pronto pra usar no meio do ano pra voltar a usar o Arch. Um ponto importante é que lá por 2017 eu comecei a usar o xubuntu com o gerenciador de janelas i3, antes de começar a usar o mac estava usando o Xmonad nesse guia eu levo em consideração a instalação do Xmonad pois já tenho meus arquivos de configuração que basicamente devo copiar, caso tenha interesse você pode ver no meu GitHub. Um disclamer antes do guia, na verdade eu achei a configuração do Arch relativamente tranquila, a documentação oficial, além de que pra mim me enrolei em alguns pontos que não estão muitos explicitos ali, então por isso fiz esse guia, dois vídeos que me ajudaram muito foi esse do Diolinux e essa do Derek Taylor, que alias também tem materiais muitos bons. Verificando UEFI Mode Verificar o bootmode se o comando abaixo der erro é por que está no UEFI mode Pode ser que essa pasta não exista ai o computador não tem suporte a UEFI ls /sys/firmware/efi/efivars Gerando o particionamento Aqui acredito que é algo bem pessoal, cada um organiza do jeito que acha melhor eu particularmente uso um / /boot /home /swap usando uma estrutura de partições GPT, caso você não saiba o que é de uma olhada nesse artigo do sempreupdate. Particionar o disco fdisk -l #lista discos fdisk /dev/sda # ou o disco que vc quer particionar exemplo de criação com comandos para o /boot - n - 1 - 2048 - +200M # Pra criar uma partição existente como swap - t - 2 # numero da partição - 19 # Código do swap # Bootloader - t - 1 - 1 # EFI Filesystem ou 4 bios boot se for MBR Agora precisamos formatar as partições pra isso usamos o mkfs e no caso do swap usamos o mkwap e swapon. Formatar partições mkfs.ext4 /dev/sda1 # Swap mkswap /dev/sda2 swapon /dev/sda2 Instalar dostools pacman -S dosfstools Formatar a partição do boot mkfs.fat -F 32 /dev/sda1 # Pode ser BIOS boot ou EFI que é a opção 1 Montando os filesystems Bom o próximo passo é montar o filesystem para fazer a instalação além de montar os diretórios que vão ficar separados em partições diferentes como o /boot e o /home. Acho bom enfatizar que o nome das partições vai variar dependendo de como você particionou, no meu caso vai ser /dev/sda1 /dev/sda2 /dev/sda3 e /dev/sda4, porém abaixo deixei da forma mais genérica. Montar o filesystem mount /dev/root_partition /mnt Criar pastas de boot e home mkdir /mnt/home mkdir /mnt/boot/ # caso EFI tem que ser /mnt/boot/EFI Montar o filesystem mount /dev/mount-boot /mnt/boot mount /dev/mount-home /mnt/home Instalação Bom agora chegou a hora da instalação, como você vai ver é bem simples: instalar os pacotes básicos pacstrap /mnt base base-devel linux linux-firmware Agora vamos gerar o fstab, se não sabe o que é o fstab da uma conferida nesse vídeo do Diolinux. Gerar o fstab genfstab -U /mnt &gt;&gt; /mnt/etc/fstab Agora vamos montar o root do arch linux. Mudar a montagem pra root arch-chroot /mnt Setar hora local ln -sf /usr/share/zoneinfo/America/Sao_Paulo /etc/localtime hwclock --systohc Instalar o neovim ou editor da sua preferência. pacman -Sy neovim Editar o arquivo /etc/locale.gen e descomentar o en-UTF8 ou a lingua que você usa como pt_BR-UTF8 # depois gerar os arquivos locale-gen Criar arquivo /etc/locale.conf e add a linguagem padrão do sistema LANG=en_US.UTF-8 Hostname Add o hostname em /etc/hostname Editar o /etc/hosts /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname.localdomain myhostname Gestão do USER Definir senha do root passwd Add user useradd -m -g users -G wheel,audio,video,storage nome_desejado_para_o_usuario Add no /etc/sudoers myuser ALL=(ALL) ALL Atualizar agora o usuário que eu criei com o passwd. passwd nome_desejado_para_o_usuario Pacotes adicionais Instalar pacotes adicionais (pra wifi continuar funcionando no pos instalação) pacman -S dosfstools os-prober mtools network-manager-applet networkmanager wpa_supplicant wireless_tools dialog sudo Grub Acho que foi a parte que mais me enrosquei, importante que precisa já ter criado e formatado, além disso aqui é importante que ele usa pacotes diferentes dependendo do tipo da sua partição do boot. Instalar o GRUB pacman -S grub os-prober # MBR grub-install --target=i386-pc --recheck /dev/sda # EFI pacman -S efibootmgr grub-install --target=x86_64-efi --bootloader-id=grub_uefi --recheck CONFIG grub-mkconfig -o /boot/grub/grub.cfg Pós Instalação Primeiro vou habilitar o networkmanager pois senão não vai habilitar a rede. Hábilitar o network manager systemctl enable NetworkManager Depois disso reinicio e testo através de um ping se está funcionando a rede além é claro de logar com o meu usuário, agora pra usar o pacman vamos usar o sudo. Instalar o básico pra usar o Xmonad e algumas aplicações sudo pacman -Syy xorg xorg-xinit xf86-video-fbdev(ou sua placa de video) nitrogen picom firefox neovim ranger rxvt-unicode sudo pacman -Syy lightdm lightdm-gtk-greeter xmonad xmonad-contrib xmobar dmenu kitty Ali instalo dois terminais o urxvt e o kitty, isso acontece pois quando fiz a instalação tive problemas com o kitty no inicio da configuração, então uso o urxvt e depois de copiar todas as minhas configs eu mudo para o kitty, já que o caração de usar um tilling manager é ter acesso fácil ao terminal. Configurar o .xinitrc copiando o exemplo do xorg pra sua home cp /etc/X11/xinit/xinitrc .xinitrc Adicionar o arquivo o start do nitrogen do picom e do xmonad # Remover twm &amp; ... exec xterm -geometry 80x66+0+0 -name login #Adicionar exec xmonad Bom com essa configuração eu já consigo iniciar o Xmonad, eu gosto de deixar ele funcional já por que se houver algum problema pra subir o Xorg ou o Xmonad ele ainda vai entrar em modo texto. Testar a inicialização startx Bom agora aqui eu copio meus arquivos de configuração, se você não tem os seus pode usar o meu clicando aqui. Copiar os arquivos de configuração do xmonad e do xmobar # criar diretório .xmonad # criar diretório .config/xmobar Normalmente eu reinicio logo novamente e dou um startx só pra ter certeza que tudo está funcionando, ai sim eu habilito o lightdm pra iniciar tudo já no modo gráfico. Habilitar o lightdm sudo systemctl enable lightdm Depois disso, eu começo a configurar o meu ambiente de desenvolvimento mas, o sistema já está pronto pra ser usado. Caso tenham alguma dúvida pode colocar nos comentários que ajudo da melhor maneira que conseguir."},{"title":"Desafio de prática - Regras","description":null,"tags":[],"slug":"desafio-de-pra-tica-regras","html":"Projeto Precisa definir um período em meses ou anos Mapear o que quer aprender O plano precisa ser horas de prática estudos tem que ser a parte e não é necessário registrar Fazer cada projeto com duração máximo de 1 mês Escopo de projetos futuros pode ser corrigido Regras para cada projeto Desenhar um mapa (Por que? O que? Como?) Artigo antes do projeto com o escopo e o mapa Retrospectiva depois do projeto Precisa ser público As horas precisam ser de prática Cada projeto precisa ser quebrado em pequenas atividades Comemorar entrega do projeto Comomorar cada habilidade que foi aprendida Durante as sessões de prática Aspecto que quer melhorar Precisa ser especifico Registrar o dia-a-dia diário de bordo ** Ser específico ** Por o que quer melhorar ** Por detalhes que ache relevante Metas ambiciosas"},{"title":"Desafio de prática - Plano","description":null,"tags":[],"slug":"desafio-de-pra-tica-plano","html":"Desafio de prática Olá, bom estou oficialmente abrindo meu desafio de prática público de 2022. Como funciona? As regras eu disponibilizei nesse link, ainda posso melhorar um pouco ele mas, o resumo está lá. A idéia é fazer um compromisso público de alcaçar um objetivo, usando projetos no máximo mensais onde vou praticar determinadas habilidades para alçar um objetivo. A ideia desse desafio é fazer um compromisso para praticar algumas habilidades, isso não contabiliza horas de estudo especifico, durante cada sessão de prática ele vai ter objetivos e a ideia caso aconteça algum bloqueio é tentar se desbloquear apenas vendo as documentações de sistemas. Além disso trabalhando com projeto pequenos, tarefas como baby steps e feedback contínuo que eu chegue a um grau mais elevado de conhecimento no fim desse desafio, ou seja, a ideia é conseguir entrar muito melhor do que entrei. Meu desafio Para 2022 preciso dar um ponto em alguns projetos que abri e também quero lançar meu primeiro jogo na steam. Então dividi os dois primeiros meses no ano para organizar 2 projetos que já tenho aberto, ai os próximos 10 meses vão ser focados no desenvolvimento de jogos e esses jogos vão tanto me ajudar a trabalhar habilidades que uso no trabalho quanto habilidades pro meu jogo. Nesse ano vou focar em desenvolver pixel art e trabalhar com uma engine em rust pro meu jogo na qual vou compilar pra steam. Nesse desafio estou calculando investir 20 horas mensais de prática, que é o máximo que vou conseguir no momento. Estou inicialmente pensando em fazer alguns jogos no estilo de livro-jogo texto, pois são bem simples e da pra fazer tudo com apenas programação, sendo que imagens seriam um plus, mas dentro desse desafio não pretendo eu mesmo criar os fluxos da história pretendo pegar pronto de algum amigo que se interessar =-). Projetos ** Janeiro ** Projeto do template fastapi, vou montar um cli pra criar um projeto simples e a evolução do exemplo usando a sessão dos dados como injeção de dependência. Além disso transformar isso numa lib e publica-la no pypi. ** Fevereiro ** Projeto do fast-ecommerce criar uma documentação em monorepo, adicionar testes via github actions e atualizar dependências com o mínimo de refatoração. ** Março ** Criar um livro-jogo usando vue/ts e python/fastapi. ** Abril ** Criar um pixel art pro jogo de Março, a abertura do jogo e o encerramento. ** Maio ** Criar um livro-jogo usando vue/ts e rust/actix. ** Junho ** Criar em pixel art 10 diagramações do jogo do mês anterior fora a abertura e o encerramento. ** Julho ** Criar um livro-jogo usando uma engine de games em rust no momento a mais provavel é a bevy. ** Agosto ** Criar em pixel art 20 diagramações do jogo do mês anterior fora a abertura e o encerramento. ** Setembro ** Criar um jogo simples de plataforma usando apenas uma tela. ** Outubro ** Criar um jogo simples de plataforma com uma fase e power-ups ou fazer essa evolução no jogo do mês anterior. ** Novembro ** Criar um jogo simples de plataforma com duas fases e power-ups ou fazer essa evolução no jogo do mês anterior. ** Dezembro ** Criar um jogo simples de plataforma com quatro fases e power-ups ou fazer essa evolução no jogo do mês anterior. Além de publicar ele na steam. Todos os objetivos para cada projeto eu coloquei no mapa abaixo: Mapa de objetivos dos projetos Motivação A ideia é conseguir provar uma tese que venho estudando em vários livros e cursos, onde direcionando meu estudo exclusivamente para pratica deliberada e através de projetos pequenos, com feedback rápido, fail fast e uma prática metódica eu consiga me desenvolver mais rapidamente. E sim a ideia não é nem lançar curso e nem livro sobre aprendendo a aprender, mas sim tentar provar que com os conceitos que coloquei na minha postagem de regras vou conseguir aprender um conhecimento e fixa-lo mais rapidamente e assim conseguir ajudar outras pessoas com as postagens que eu for fazendo durante o 2022. Bom os planos e retrospectivas dos projetos vou publicando aqui e vou tentar sempre que possível compartilhar no twitch, bom é isso por enquanto e até 2022."},{"title":"Desafio de prática - Escopo Janeiro","description":null,"tags":[],"slug":"desafio-de-pra-tica-escopo-janeiro","html":"Por que? Melhorar o conhecimento em python Montar minha primeira lib no pypi Melhorar o conhecimento em GitHub Actions Bom o objetivo desse projeto é conseguir completar a talvez unica fase prevista no projeto de templates fastapi, assim montar o exemplo da documentação do fastapi que tem apenas o main.py e o meu exemplo melhorado do repositório que mencionei, além disso quero usar uma ferramenta de script como o typer do próprio criador do fastapi pra adicionar as funcionalidades: add template, inicializar/gerar/rodar migrations e rodar o app do template. Como o template sem o cookiecutter está pronto o maior trabalho vai ser fazer ele funcionar com o cookiecuter em si, além de fazer os testes rodarem via github actions. O que? Conceitos Aprender typer Aprender a gerar um teste de unidade no GitHub Actions Publicar uma lib no PyPi Aqui basicamente vou estudar o typer que é a ferramenta de script feita pelo criador do fastapi, aprender a gerar os testes de unidade sem containers via GitHub Action e por fim como publicar uma biblioteca no PyPi. Fatos Montar um pré-commit no projeto Adicionar o projeto badges de build, dependencias e analise estática O projeto precisa ser desenvolvido como lib O projeto precisa poder criar um template O projeto precisa poder iniciar - gerar - migrar as migrations do bd O projeto precisa poder iniciar o projeto com uvicorn Procedimentos Reforçar conceitos de OO Reforçar conceitos de teste Reforçar o conhecimento em cookiecuter Reforçar conhecimentos em desenvolvimento web com python Como? Cookiecutter Gerar 2 projetos diferentes Opções do poetry Adicionar como o exemplo o projeto design api Typer: Criar o prefixo &quot;fast&quot; Receber paramêtros (create | db [init/make/migrate] | runserver) GitHub Actions Rodar testes de unidade (sem db) Rodar o coverage Adicionar o sonarcloud Git Rodar o prospector Rodar o safety Basicamente nesse projeto é consultar as documentações e aplicar os conceitos acima, estimativa inicial pra todos esses passo é fazer tudo em 20 horas."},{"title":"Desafio de prática - Escopo Fevereiro","description":null,"tags":[],"slug":"desafio-de-pra-tica-escopo-fevereiro","html":"Por que? Atender demandas de um cliente antigo de um projeto já criado Aplicar o método da refatoração Melhorar o conhecimento em GitHub Actions Bom o objetivo desse projeto é atender algumas demandas que já me foram pedidas num projeto antigo fast-ecommerce. O objetivo é transformar num monorepo, ajustar testes, criar features e fazer pequenos refactors durante o processo. O que? Conceitos Testar a migração do vue 2 para o vue 3 Aprender a gerar um testes de unidade no GitHub Actions Exercitar refactors Aqui basicamente tem estudos mais focados em testes e GitHub Actions, mas o projeto vai ser mais focado na prática. Fatos Montar um pré-commit no projeto Adicionar o projeto badges de build, dependencias e analise estática O projeto front precisa ser migrado para vue3 Os projetos precisam ficar num monorepo O projeto front precisa remover dependências do cliente O projeto back precisa sofrer alguns refactors O projeto front precisa aceitar scripts do tipo typescript Ajustes sugeridos no sonarcloud Procedimentos Reforçar conceitos de arquitetura Reforçar conceitos de teste Reforçar os conhecimentos de vue3 Reforçar os conhecimentos de typescript Como? Vue3 migrate Rodar script de migração Resolver conflitos Bônus - Fazer refactors para composition API Typescript: Refatorar scripts já usando typescript GitHub Actions Rodar testes de unidade (sem db) Rodar o coverage Ajustes no sonarcloud Git Rodar o prospector Rodar o safety Basicamente é um projeto focado em atender uma demanda, montar features, e fazer melhorias."},{"title":"Afiando o machado 2021","description":null,"tags":[],"slug":"afiando-o-machado-2021","html":"Afiando o machado em 2021 Bom estamos começando mais um ano, deixando esse difícil ano de 2020 pra trás, então decidi no hiato entre 2020 e 2021 de revisar meu ambiente de desenvolvimento, então gostaria de compartilhar com vocês como está ficando. Pra começar é bom colocar as linguagens / frameworks que tenho configuradas no meu ambiente : Dart / Flutter Python / Flask / Django / FastAPI Javascript / Vue Rust Go Um ponto que acho interessante frisar que em 2021 vou ter um ano atípico no que diz a sistema operacional, vou começar o ano com o Mac, lá pelo meio do ano vou usar o Windows e no fim do ano devo voltar pro Linux, mais precisamente o Arch se não viu meu artigo anterior acesse aqui ali eu já fiz uma guia da minha instalação. Com isso meu ambiente de desenvolvimento tem que ser o mais flexível possível, além de tudo eu gosto de trabalhar no terminal então como vou usar o WSL2 no Windows (talvez até um virtualbox mesmo) vai ser mais tranquila essa transição. Legal já frisar que nesse artigo específico não vou explicar detalhadamente a configuração de cada ferramenta, pretendo fazer isso ao longo do ano, mas já queria falar quais ferramentas estou usando hoje. Outro ponto importante pra mim é eu gosto de experimentar uma coisa ou outra, mas sempre de forma separada do fluxo padrão, pois eu posso achar que um projeto ainda não está tão legal pra mim, simplesmente desistir ou ainda intrega-lo no meu workflow principal, removendo a ferramenta anterior, faço isso muito por curiosidade sobre o desenvolvimento de outras ferramentas e vez ou outra acabo incorporando uma ferramenta nova durante o ano ou mesmo um plugin. Algo pra entrar no meu workflow precisa me deixar mais produtivo e não o contrário. Pra facilitar a sua leitura deu dividi o artigo nos tópicos abaixo: Fontes Prompt de comando Emulador de terminal Multiplexador Python Dart / Flutter Vue Editor Docker Conclusão Fontes Uma coisa que pode não parecer muito importante, mas que no meu workflow eu acho super importante é o uso do nerdfonts, pois ele me dá um conjunto de fontes e ícones que vou colocar tanto no meu terminal, quanto no meu editor de texto, como eu fico 80% do meu tempo dentro do terminal ter boas fontes e bons ícones ajuda a deixar o ambiente mais agradável, sei que muita gente gosta e vive bem com um terminal mais &quot;seco&quot; e vive bem com isso. Além disso, eu pretendo usar também os ícones e fontes no próprio Xmonad. Tema Um tema que venho usando e gosto muito é o dracula, o bom dele é que basicamente posso usar o mesmo esquema de cores em todas as ferramentas que uso, inclusive no meu browser, então tudo que eu posso eu tento usar o drácula como tema. No caso do Xmonad ainda não tem um tema, mas pretendo resolver essa pendência =D. Prompt de comando Aqui eu uso o zsh como shell, para complementar uso o ohmyzsh pois ele me trás vários plugins úteis para o dia-a-dia e o starship para customizar a visualização do prompt pois ele possui várias opções de customizar a visualização e acho ele infinitamente mais leve que o tema do powerlevel10k que me dá várias opções mas, pelo menos no mac hoje fica bem pesado quando uso. Com isso já consigo usar autocomplete e ter alguns indícios visuais de um repositório, e no meu .zshrc eu vou colocando as configurações e alias de comando que mais uso no dia-a-dia. Uma coisa que penso em experimentar durante o ano é o fish shell e o elvish shell. Emulador de terminal Pode não parecer, mas minha ideia é ter o menor número de ferramentas / plugins dentro do meu workflow, pois é fácil você configurar algo e raramente usar. Porém no caso do emulador de terminal ainda tenho um dilema estou usando 2, o alacritty e o kitty. O alacritty é um emulador de terminal pequeno, leve e poderoso, ele segue o conceito dos emuladores com poucas features, o que é perfeito pra usar em tilling manager como o Xmonad ou o i3, porém hoje ele não tem uma feature que estou usando no momento, que é a compatibilidade para fontes com ligadura, tipo o fira code. Por conta disso estou usando o kitty, que é um emulador de terminal com muitos recursos, porém fora suas configurações básicas, não uso as features tmux like dele, muito por que acho que o próprio alacritty no futuro vai ter essa feature e eu devo voltar pra ele, e não me entenda mal o kitty é ótimo, mas muitas das features dele eu já resolvo com tmux + Xmonad, o que pode parecer estranho já que quero ter sempre o mínimo possível de ferramentas, mas durante esse ano se em algum momento eu achar que o Kitty está sendo mais vantajoso com certeza vou permanecer nele. Mas por enquanto a ideia é ter o alacritty como emulador de terminal principal. Multiplexador Aqui só tem uma ferramenta que uso que é o tmux, ele nada mais é que um multiplexador, trabalha com abas além de manipular as janelas de maneira muito parecida com o tilling manager, mas então por que usar isso até pelo que falei sobre o kitty? Uso principalmente por conta de gerar uma sessão e uma sessão básica, e o que isso quer dizer? Primeiro quando crio uma sessão no tmux, mesmo que feche o terminal a sessão ainda vai ficar de pé até que você reinicie o computador ou mate a sessão. Assim mesmo que acidentalmente feche o terminal a minha sessão vai continuar em pé normalmente. Agora outra feature que o tmux tem é poder criar templates de sessões, ou seja, já posso configurar quantidade de janelas, diretório que vai abrir além de dar start em alguma ferramenta como um git fetch ou coisa do tipo. Hoje uso apenas uma sessão e abro tudo que eu possa precisar, isso até por que hoje estou usando o mac e é mais conveniente abrir tudo já, porém quando voltar a usar o linux penso em criar sessões especializadas (editor, kubernetes, dart e etc), pois ao invés de ficar trabalhando com várias abas no tmux, posso trabalhar com uma apenas mas, com o workflow da atividade que vou trabalhar já. Voltando ao kitty ele faz isso também tanto em manter sessão quanto montar templates de uso, aqui a preferência é por já ter o costumo com os atalhos do tmux, conforme esse ano for passando talvez eu faça alguns testes usando só o kitty, por que talvez eu ganhe mais usando só ele ao invés do alacritty + tmux. Python Aqui nessa sessão eu configuro a versão do python e meu ambiente virtuais, primeira ferramenta que uso é o pyenv, no caso ele vai gerenciar a versão do python que estou usando em determinado projeto, por exemplo, hoje tenho projetos que usam python 3.5, 3.7 e 3.9, isso muito por que alguns projetos usam bibliotecas de terceiros que são incompatíveis com versões mais recentes do python. Além disso o pyenv me dá a possibildade de não &quot;sujar&quot; a versão do python do sistema (mac/linux), pois essa versão vai ser usada para as aplicações do sistema, e prefiro deixar ela intocada, isso é interessante se você algum dia já instalou várias bibliotecas no seu python de sistema e um aplicativo já parou de funcionar por conflito, tendo a versão do python segregada te ajuda a resolver esse problema, além disso o pyenv você consegue configurar na sua versão global todas as versões que vc está usando. O pyenv tem plugins para gerenciar suas virtuals envs, porém hoje eu prefiro usar o poetry, ele ajudar a manter o controle das bibliotecas que uso em determinado projeto, mantém uma árvore de dependências, versionando inclusive lib dependentes do meu projeto além de criar minha virtualenv tudo com um comando, e isso é uma das coisas que mais gosto dele. Dart / Flutter Aqui não tem muito segredo, pois eu simplesmente uso o procedimento do site do flutter pra fazer a instalação, como não mexo tanto no dart/flutter (esse ano devo usar mais), então a configuração padrão já me atende sem muito problema. Aqui talvez num futuro se precisar trabalhar com versões diferentes do dart uma solução seria usar o [asdf] (https://github.com/asdf-vm/asdf), mas ainda não sei se seria necessário. Vue Para trabalhar com vue eu preciso de duas coisas, primeiro o NVM com ele eu consigo usar a versão do Node que eu quiser para determinado projeto de forma fácil e rápida, é um processo bem parecido com o pyenv, a segunda coisa que preciso é o VueCLI que já ajuda a criar os projetos VUE de forma bem rápida, além de subir um plugins pré configurados. Editor Já usei vários editores na vida, mas nos últimos anos tenho dado preferência ao vim e mais especificamente ao NeoVim, muito por que mesmo tendo vários plugins nele ainda é bem leve para se trabalhar. O NeoVim quando instalado já possui várias configurações interessantes, das quais pretendo colocar em outro post que já ajuda bastante, mas gostaria de falar aqui dos principais plugins que uso hoje. Para ter um intellisense e alguns auto formats eu uso o COC ele já me da uma gama de possibilidades de configurar o interpretador para python, js, vue e dart e sem muito esforço, sua única inconveniência ao meu ver é ter que criar uma pasta de configuração .vim em todos os projetos que trabalho. Com ajuda do COC eu também configuro a parte do cTags para poder funcionar os Go To na navegação do código. NerdTree eu uso para poder navegar nos diretórios do projeto e poder alterar, adicionar e remover pastas e diretórios é bem fácil de usar e bem funcional. FZF, CTRLP e o FERRET, são um conjunto de plugins para fazer busca tanto no diretório quanto detro dos arquivos junto com o RG e o AG para aplicar os algoritmos de busca o que otimiza o tempo para fazer as buscas. Com isso já consigo fazer buscas rápidas pelo meu código. VIM-FUGITIVE pra mim um dos melhores plugins para dominar no vim, com ele eu consigo trabalhar e ir fazendo meus commits, pulls, pushs sem precisar ter uma outra janela do terminal pra ficar fazendo isso, o que acaba facilitando muito a vida, além de conseguir fazer um gitdiff quando em pull acontece algum conflito com minhas alterações. Bom poderia falar de muitos outros plugins que uso mas, acredito que hoje esses são os mais essenciais pro meu dia-a-dia de trabalho. Docker Aqui também uso as instalações padrões do docker e docker-compose, além de muitas vezes ainda não desenvolver diretamente no docker, todas as estruturas de apoio para o desenvolvimento como db, filas, ferramentas de monitoração e etc, eu rodo no docker, e também quando preciso simular algum problema que não ocorre quando subo o projeto diretamente no poetry eu acabo apelando pra subir o projeto via docker-compose e ver se consigo replicar o erro. Penso que quando você começa a trabalhar com docker, você vai sentir dificuldade de deixar ele, pois ele ajuda muito a deixar as configs do seu sistema limpas, pois todas as bibliotecas, instalações e afins estão contidas dentro do container. Conclusão A ideia aqui foi apresentar o conjunto de ferramentas que uso no meu workflow de trabalho no dia-a-dia, aqui além de talvez você me falar que instalando o pacote do jetbrains eu teria quase tudo isso já na mão. Mas, como sempre digo a melhor ferramenta é a que você se sente mais produtivo, acredito que o meu workflow tem uma produtividade bem alta e com um baixo custo de recursos (vendo que tenho um mac de 2014 e um notebook que é um core 2 duo com 4gb de ram), além disso ter um workflow via terminal é extremamente poderoso pois faço praticamente tudo que preciso apenas usando alguns comandos ou atalhos no teclado. Acredito que no caso de um workflow como o meu tem um grande trabalho em &quot;esculpir&quot; as configurações, porém ele fica exatamente do jeito que você quer ao contrário de um jetbrains ou mesmo o vscode que você acaba ficando preso a algumas definições da ferramenta. Enfim, espero que você goste e convido a compartilhar ferramentas que você ache legal pra trabalhar num workflow usando terminal ou algum outro workflow que você use, gosto muito de conhecer outros workflows de trabalho =). Então é isso e até o próximo artigo."},{"title":"About","description":null,"tags":[],"slug":"about","html":"Hi, edit about.md to change this content."},{"title":"52 semanas de planejamento em 2023","description":null,"tags":[],"slug":"52-semanas-de-planejamento-em-2023","html":"52 Semanas de planejamento em 2023 Olá estamos na primeira semana do ano e muita gente faz resoluções de ano novo e cria planos, e talvez você tenha colocado como meta se planejar melhor. Por conta dissso quero te ajudar e explicar algo que fiz em 2023 e foi uma grande conquista. Bom eu consegui me planejar em todas as 52 semanas definindo um foco para cada semana e isso pra mim foi algo inédito. Veja bem cada semana eu me sentei por um breve período e defini todos meus compromissos agendados, planejamentos e lembretes além é claro de qual seria o meu foco em cada semana. Só pra sua curiosidade essa primeira semana de 2023 meu foco foi criar o meu primeiro vídeo no youtube nesse ano de 2024 sobre esse tema. Mas, antes de explicar como eu faço meu planejamento semanal, gostaria de falar que nesse ano de 2024 estou iniciando minha jornada como game developer que é um dos meus grandes objetivos para esse ano e comecei com um desafio de aprender bevy engine o suficiente para fazer um tutorial no meu canal do youtube no final desse período, mas o dia a dia nessa jornada vou publicar no meu youtube além do meu servidor no discord eu convido você para me acompanhar. Vale reforçar que esse planejamento me ajuda muito a me guiar com minha priorização do que vou fazer e o tempo que vou dedicar para cada assunto que preciso fazer na vida seja na vida pessoal ou no trabalho o que no método que uso é chamado de contexto. Então para iniciar o método que uso é o MVO feito pela Thais Godinho onde trabalhamos lá com metas, objetivos e projetos vendo coisas a longo prazo até o planejamento do dia, mas hoje vamos focar no planejamento da semana e do dia. Pra fazer esse planejamento é possível usar várias ferramentas online e também no papel mas, hoje vou usar o google calendar que é a ferramenta que uso no dia a dia. Eu sou uma pessoa que gosta muito de usar ferramentas open source, mas no caso do calendário até hoje não consegui uma ferramenta de calendário que funcionasse comigo e tenha uma boa sincronização com o google calendar pois fora meu planejamento eu tenho o calendário da minha esposa e filho para acompanhar. Caso você conheça alguma ferramenta legal que faça isso pode colocar nos comentários eu adoraria experimentar. Então inicialmente com uma conta do google já criada eu entro no Google Calendar, em português fica como Google Agenda ai no software já vem com uma agenda padrão que é o que a maioria usa, nele eu renomeio para &quot;Pessoais&quot;, ai crio duas novas agendas uma chamada &quot;Planejados&quot; coloco uma cor cinza e outra chamada &quot;Lembretes e Informações&quot; e coloco um tom amarelo. Ai como funciona cada agenda? Agendados: São compromissos no qual eu tenho um horário marcado, como uma reunião, um horário no dentista ou qualquer outra coisa que tem um horário definido. Planejados: São coisas que você precisa fazer mas, não tem um horário fixo, pode ser arrumar a casa, um projeto que você está trabalhando ou mesmo um horário pra estudar por exemplo. Também deslocamento pra um compromisso externo eu defino um bloco planejado pois além de um lembrete do horário que preciso sair tenho uma forma visual de ver o tempo que planejei para chegar no local. É importante também pensar que essa agenda você não vai colocar a atividade em si por exemplo eu estou aprendendo a bevy engine, não vou criar um evento &quot;Setup do projeto&quot; outro &quot;Criar menu inicial&quot;, outro &quot;Importar assets&quot; eu vou apenas criar um evento chamado Bevy e ai as atividades que preciso fazer eu uso outras ferramentas. Lembrete e informações: São atividades que preciso fazer no dia e não tem um horário especifico como pagar uma conta, jogar o lixo fora ou ver o status de algum pendencia no site do governo por exemplo. Importante reforçar de que como esses compromissos não tem uma hora definida eu deixo como um evento do dia inteiro no calendar. Como disse em cada semana eu defino um foco e ele é um evento do tipo &quot;Lembretes e Informações&quot; no meu calendário, então eu defino ele como um evento do dia inteiro e coloco o início dele no domingo e o final no sábado. E como ele funciona? O foco da semana é sua bussolá ele vai aparecer em todos os dias no seu calendário e é um exercício diário para você ver se está priorizando atividades do seu foco no dia a dia ou se está desviando para outro caminho. Com isso como funciona o meu planejamento? Eu na semana atual defino a próxima semana então já vejo os compromissos que tenho que são agendados, crio blocos da agenda de planejados para as atividades e finalmente vejo o que eu preciso lembrar de fazer como pagar uma conta e coloco como lembrete. Claro que nem tudo precisa ser feito de uma vez só há algumas coisas que vão aparecendo no decorrer da semana que vou colocando para as próximas semanas. O que eu aprendi em 52 semanas de planejamento? Eu aprendi algumas coisas depois dessas 52 semanas e fui ajustando e aprendendo no decorrer das semanas. Há semanas que seu foco vai ser sobreviver: Há momentos na nossa vida que estamos num turbilhão de problemas que tudo está caótico e realmente não conseguimos focar em nada, nesses caso eu coloca como foco &quot;sobreviver&quot; pois, o foco era simplesmente conseguir passar por aquele momento difícil. E é importante perceber se você passou mais de uma semana com o foco em sobreviver, vale a pena repensar na sua semana ou mesmo procurar ajuda. Planeje seus descaço: Mesmo férias é importante planejar e não digo de planejar viagens e tal, mas ver compromissos que ou coisas que você precisa fazer nas suas férias. E caso não tenha nada mesmo pra fazer só coloque como foco &quot;Relaxa&quot;. Não faça a agenda Tetris: É importante criar intervalos entre um compromisso e outro no qual você pode usar pra beber uma água, ir no banheiro ou mesmo responder suas mensagens. Lembre-se você não é uma máquina, essas pequenas pausas entre os eventos são importantes no seu dia a dia. As vezes você não vai conseguir seguir seu foco: Há semanas que você se planejou e organizou mas, tudo mudou. As vezes acontecem coisas externas no qual não podemos controlar e você vai precisar replanejar tudo ou mesmo descartar todo o planejamento já feito e está tudo bem. O importante é ver o que você não pode fazer que precisa mover pra próxima semana e o que você vai deixar pra trás mesmo. A vida é dinâmica então não da pra seguir sempre um plano a risca. Caso queira ver o material original desse método o link vai estrar na descrição. Então é isso que queria lhe mostrar, caso queira ver mais conteúdos como esse pense em se inscrever no canal e ativar o sininho e se quiser trocar uma ideia sobre organização pode entrar no nosso servidor no discord."}]