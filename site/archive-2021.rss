<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Jonatas</title><link>https://blog.jonatasoliveira.dev/</link><description>Aprendendo a fazer jogos e se aventurando pelo Rust e Python</description><pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate><lastBuildDate>Tue, 10 Jun 2025 09:19:52 GMT</lastBuildDate><generator>marmite</generator><item><title>Desafio de prática - Escopo Janeiro</title><link>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-escopo-janeiro.html</link><description><![CDATA["Escopo Inicial - Janeiro"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-escopo-janeiro.html</guid><pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h1><a href="#por-que" aria-hidden="true" class="anchor" id="por-que"></a>Por que?</h1>
<ul>
<li>Melhorar o conhecimento em python</li>
<li>Montar minha primeira lib no pypi</li>
<li>Melhorar o conhecimento em GitHub Actions</li>
</ul>
<p>Bom o objetivo desse projeto é conseguir completar a talvez unica fase prevista no <a href="https://github.com/jonatasoli/fastapi-template-cookiecutter">projeto de templates fastapi</a>,
assim montar o exemplo da documentação do fastapi que tem apenas o main.py e o meu exemplo melhorado do repositório que mencionei, além disso quero usar uma ferramenta de script como o typer do próprio criador do fastapi pra adicionar as funcionalidades: add template, inicializar/gerar/rodar migrations e rodar o app do template.</p>
<p>Como o template sem o cookiecutter está pronto o maior trabalho vai ser fazer ele funcionar com o cookiecuter em si, além de fazer os testes rodarem via github actions.</p>
<h1><a href="#o-que" aria-hidden="true" class="anchor" id="o-que"></a>O que?</h1>
<h2><a href="#conceitos" aria-hidden="true" class="anchor" id="conceitos"></a>Conceitos</h2>
<ul>
<li>Aprender typer</li>
<li>Aprender a gerar um teste de unidade no GitHub Actions</li>
<li>Publicar uma lib no PyPi</li>
</ul>
<p>Aqui basicamente vou estudar o typer que é a ferramenta de script feita pelo criador do fastapi, aprender a gerar os testes de unidade sem containers via GitHub Action e por fim como publicar uma biblioteca no PyPi.</p>
<h2><a href="#fatos" aria-hidden="true" class="anchor" id="fatos"></a>Fatos</h2>
<ul>
<li>Montar um pré-commit no projeto</li>
<li>Adicionar o projeto badges de build, dependencias e analise estática</li>
<li>O projeto precisa ser desenvolvido como lib</li>
<li>O projeto precisa poder criar um template</li>
<li>O projeto precisa poder iniciar - gerar - migrar as migrations do bd</li>
<li>O projeto precisa poder iniciar o projeto com uvicorn</li>
</ul>
<h2><a href="#procedimentos" aria-hidden="true" class="anchor" id="procedimentos"></a>Procedimentos</h2>
<ul>
<li>Reforçar conceitos de OO</li>
<li>Reforçar conceitos de teste</li>
<li>Reforçar o conhecimento em cookiecuter</li>
<li>Reforçar conhecimentos em desenvolvimento web com python</li>
</ul>
<h1><a href="#como" aria-hidden="true" class="anchor" id="como"></a>Como?</h1>
<p><a href="https://cookiecutter.readthedocs.io/en/latest/">Cookiecutter</a></p>
<ul>
<li>Gerar 2 projetos diferentes</li>
<li>Opções do poetry</li>
<li>Adicionar como o exemplo o projeto <a href="https://github.com/jonatasoli/fastapi-design-api-example">design api</a></li>
</ul>
<p><a href="https://typer.tiangolo.com/">Typer</a>:</p>
<ul>
<li>Criar o prefixo &quot;fast&quot;</li>
<li>Receber paramêtros (create | db [init/make/migrate] | runserver)</li>
</ul>
<p><a href="https://github.com/features/actions">GitHub Actions</a></p>
<ul>
<li>Rodar testes de unidade (sem db)</li>
<li>Rodar o coverage</li>
<li>Adicionar o <a href="https://sonarcloud.io/">sonarcloud</a></li>
</ul>
<p><a href="https://pre-commit.com/">Git</a></p>
<ul>
<li>Rodar o prospector</li>
<li>Rodar o safety</li>
</ul>
<p>Basicamente nesse projeto é consultar as documentações e aplicar os conceitos acima, estimativa inicial pra todos esses passo é fazer tudo em 20 horas.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Desafio de prática - Plano</title><link>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-plano.html</link><description><![CDATA["Meu desafio para 2023"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-plano.html</guid><pubDate>Tue, 28 Dec 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h1><a href="#desafio-de-prática" aria-hidden="true" class="anchor" id="desafio-de-prática"></a>Desafio de prática</h1>
<p>Olá, bom estou oficialmente abrindo meu desafio de prática público de 2022.</p>
<h2><a href="#como-funciona" aria-hidden="true" class="anchor" id="como-funciona"></a>Como funciona?</h2>
<p>As regras eu disponibilizei <a href="https://jonatasoliveira.dev/blog/desafio-de-pratica-regras/">nesse link</a>, ainda posso melhorar um pouco ele mas, o resumo está lá.</p>
<p>A idéia é fazer um compromisso público de alcaçar um objetivo, usando projetos no máximo mensais onde vou praticar determinadas habilidades para alçar um objetivo.</p>
<p>A ideia desse desafio é fazer um compromisso para praticar algumas habilidades, isso não contabiliza  horas de estudo especifico, durante cada sessão de prática ele vai ter objetivos e a ideia caso aconteça algum bloqueio é tentar se desbloquear apenas vendo as documentações de sistemas.</p>
<p>Além disso trabalhando com projeto pequenos, tarefas como baby steps e feedback contínuo que eu chegue a um grau mais elevado de conhecimento no fim desse desafio, ou seja, a ideia é conseguir entrar muito melhor do que entrei.</p>
<h2><a href="#meu-desafio" aria-hidden="true" class="anchor" id="meu-desafio"></a>Meu desafio</h2>
<p>Para 2022 preciso dar um ponto em alguns projetos que abri e também quero lançar meu primeiro jogo na steam.
Então dividi os dois primeiros meses no ano para organizar 2 projetos que já tenho aberto, ai os próximos 10 meses vão ser focados no desenvolvimento de jogos e esses jogos vão tanto me ajudar a trabalhar habilidades que uso no trabalho quanto habilidades pro meu jogo.
Nesse ano vou focar em desenvolver pixel art e trabalhar com uma engine em rust pro meu jogo na qual vou compilar pra steam. Nesse desafio estou calculando investir 20 horas mensais de prática, que é o máximo que vou conseguir no momento.</p>
<p>Estou inicialmente pensando em fazer alguns jogos no estilo de livro-jogo texto, pois são bem simples e da pra fazer tudo com apenas programação, sendo que imagens seriam um plus, mas dentro desse desafio não pretendo eu mesmo criar os fluxos da história pretendo pegar pronto de algum amigo que se interessar =-).</p>
<h2><a href="#projetos" aria-hidden="true" class="anchor" id="projetos"></a>Projetos</h2>
<p>** Janeiro **</p>
<p>Projeto do template fastapi, vou montar um cli pra criar um projeto simples e a evolução do exemplo usando a sessão dos dados como injeção de dependência. Além disso transformar isso numa lib e publica-la no pypi.</p>
<p>** Fevereiro **</p>
<p>Projeto do fast-ecommerce criar uma documentação em monorepo, adicionar testes via github actions e atualizar dependências com o mínimo de refatoração.</p>
<p>** Março **</p>
<p>Criar um livro-jogo usando vue/ts e python/fastapi.</p>
<p>** Abril **</p>
<p>Criar um pixel art pro jogo de Março, a abertura do jogo e o encerramento.</p>
<p>** Maio **</p>
<p>Criar um livro-jogo usando vue/ts e rust/actix.</p>
<p>** Junho **</p>
<p>Criar em pixel art 10 diagramações do jogo do mês anterior fora a abertura e o encerramento.</p>
<p>** Julho **</p>
<p>Criar um livro-jogo usando uma engine de games em rust no momento a mais provavel é a <a href="https://bevyengine.org/">bevy</a>.</p>
<p>** Agosto **</p>
<p>Criar em pixel art 20 diagramações do jogo do mês anterior fora a abertura e o encerramento.</p>
<p>** Setembro **</p>
<p>Criar um jogo simples de plataforma usando apenas uma tela.</p>
<p>** Outubro **</p>
<p>Criar um jogo simples de plataforma com uma fase e power-ups ou fazer essa evolução no jogo do mês anterior.</p>
<p>** Novembro **</p>
<p>Criar um jogo simples de plataforma com duas fases e power-ups ou fazer essa evolução no jogo do mês anterior.</p>
<p>** Dezembro **</p>
<p>Criar um jogo simples de plataforma com quatro fases e power-ups ou fazer essa evolução no jogo do mês anterior. Além de publicar ele na steam.</p>
<p>Todos os objetivos para cada projeto eu coloquei no mapa abaixo:
<a href="https://i.pinimg.com/originals/47/b2/eb/47b2eb88d67546eb3ed3577c07dea948.png">Mapa de objetivos dos projetos</a></p>
<h2><a href="#motivação" aria-hidden="true" class="anchor" id="motivação"></a>Motivação</h2>
<p>A ideia é conseguir provar uma tese que venho estudando em vários livros e cursos, onde direcionando meu estudo exclusivamente para pratica deliberada e através de projetos pequenos, com feedback rápido, fail fast e uma prática metódica eu consiga me desenvolver mais rapidamente.
E sim a ideia não é nem lançar curso e nem livro sobre aprendendo a aprender, mas sim tentar provar que com os conceitos que coloquei na minha postagem de regras vou conseguir aprender um conhecimento e fixa-lo mais rapidamente e assim conseguir ajudar outras pessoas com as postagens que eu for fazendo durante o 2022.</p>
<p>Bom os planos e retrospectivas dos projetos vou publicando aqui e vou tentar sempre que possível compartilhar no <a href="https://www.twitch.tv/devjonatas">twitch</a>, bom é isso por enquanto e até 2022.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Desafio de prática - Regras</title><link>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-regras.html</link><description><![CDATA["Regras pro desafio de prática"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//desafio-de-pra-tica-regras.html</guid><pubDate>Mon, 27 Dec 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h1><a href="#projeto" aria-hidden="true" class="anchor" id="projeto"></a>Projeto</h1>
<ul>
<li>Precisa definir um período em meses ou anos</li>
<li>Mapear o que quer aprender</li>
<li>O plano precisa ser horas de prática estudos tem que ser a parte e não é necessário registrar</li>
<li>Fazer cada projeto com duração máximo de 1 mês</li>
<li>Escopo de projetos futuros pode ser corrigido</li>
</ul>
<h2><a href="#regras-para-cada-projeto" aria-hidden="true" class="anchor" id="regras-para-cada-projeto"></a>Regras para cada projeto</h2>
<ul>
<li>Desenhar um mapa (Por que? O que? Como?)</li>
<li>Artigo antes do projeto com o escopo e o mapa</li>
<li>Retrospectiva depois do projeto</li>
<li>Precisa ser público</li>
<li>As horas precisam ser de prática</li>
<li>Cada projeto precisa ser quebrado em pequenas atividades</li>
<li>Comemorar entrega do projeto</li>
<li>Comomorar cada habilidade que foi aprendida</li>
</ul>
<h2><a href="#durante-as-sessões-de-prática" aria-hidden="true" class="anchor" id="durante-as-sessões-de-prática"></a>Durante as sessões de prática</h2>
<ul>
<li>Aspecto que quer melhorar</li>
<li>Precisa ser especifico</li>
<li>Registrar o dia-a-dia diário de bordo
** Ser específico
** Por o que quer melhorar
** Por detalhes que ache relevante</li>
<li>Metas ambiciosas</li>
</ul>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Sintaxe literal vs Construtor em Rust</title><link>https://blog.jonatasoliveira.dev//sintaxe-literal-vs-construtor-em-rust.html</link><description><![CDATA["As ferramentas que estou usando no meu workflow de trabalho"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//sintaxe-literal-vs-construtor-em-rust.html</guid><pubDate>Thu, 08 Apr 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>Essa é uma tradução livre <a href="https://steveklabnik.com/writing/structure-literals-vs-constructors-in-rust">deste artigo</a>.</p>
<h1><a href="#estrutura-literal-vs-construtor-em-rust" aria-hidden="true" class="anchor" id="estrutura-literal-vs-construtor-em-rust"></a>Estrutura literal vs construtor em Rust</h1>
<p>Aprender o básico de uma linguagem e a sintaxe é fácil. Agora como dar sentido para todos aqueles bits pode ser um pouco mais difícil. Há uma rede de interseções de três funcionalidades do Rust que vejo pessoas usando, mas nunca vi escrito.Eu espliquei essa técnica para algumas pessoas em <em>#rust-bennigers</em> outro dia, pensei em escrever pra ajudar você também.</p>
<p>Um pequeno review, se você tem uma <em>struct</em> em Rust como este:</p>
<pre><code>struct Point {
    x: i32,
    y: i32,
}
</code></pre>
<p>Você pode usar a 'sintaxe literal do <em>struct</em>' para criar uma nova instância do struct:</p>
<pre><code>let origin = Point { x: 0, y: 0 };
</code></pre>
<p>Normalmente, esta sintaxe somente funciona se você tem acessso a propriedade da <em>struct</em> e de seu membro pela regra de privacidade do <em>Rust</em>.</p>
<pre><code>mod foo {
    pub struct Point {
        x: i32,
        y: i32,
    }

    pub fn foo(x: i32, y: i32) -&gt; Point {
        Point { x: x, y: y } // isto é bom , já que estamos no mesmo módulo
    }
}

fn main() {
    let origin = foo::Point { x: 0, y: 0 }; // isto não é bom
}
</code></pre>
<p>Nós não podemos usar a sintaxe literal <em>struct</em> na função <em>main</em> por que <em>x</em> e <em>y</em> também não são publicos.</p>
<p>Mas, dentro do mesmo módulo nós temos acesso, então funciona. Como podemos deixar <em>main</em> instanciar <em>Point</em>, se não podemos usar uma sintaxe literal? Bem, nossa função foo faz isto, então nós podemos expo-la. Seria mais conveniente se nós associarmos a uma função <em>new</em>.</p>
<pre><code>mod foo {
    pub struct Point {
        x: i32,
        y: i32,
    }
    
    impl Point {
        pub fn new(x: i32, y: i32) -&gt; Point {
            Point { x: x, y: y } // Isto é bom, já que estamos no mesmo módulo
        }
    }
}

fn main() {
    let origin = foo::Point::new(0, 0);
}

</code></pre>
<p>Certo, mas se por alguma razão nós quiséssemos que <em>x</em> e <em>y</em> sejam públicos ou ainda se quiséssemos forçar as pessoas a criar uma função <em>new</em> para criar um <em>Point</em>?</p>
<p>Talvez nossa mudança gere um efeito colateral importante. Então se trocarmos nosso código para isto:</p>
<pre><code>mod foo {
    pub struct Point {
        pub x: i32,
        pub y: i32,
    }
    
    impl Point {
        pub fn new(x: i32, y: i32) -&gt; Point {
            Point { x: x, y: y } // isto é bom, já que estamos no mesmo módulo
        }
    }
}

fn main() {
    let origin = foo::Point::new(0, 0);

    // mas, isto também:
    let origin = foo::Point { x: 0, y: 0 };
}
</code></pre>
<p>Fazendo todos os elementos de <em>Point</em> publicos, nós reativariamos a sintaxe literal, que não é o que gostariamos de chegar, então o que fazer?</p>
<p>Pra corrigir isso precisamos de dois <em>insights</em>. O primeiro é &quot;zero-size types&quot;. No Rust tem alguns tipos que não requerem nenhum armazenamento. Vamos pegar o exemplo da tupla vazia '()', ele também só tem uma possibilidade de valor que é a própria tupla vazia. Assim nós não há necessidade de armazenar nada em memória pra representa-la.</p>
<p>Se nós temos um valor válido, nós já saberemos o que ele é. Isso significa que quando a aplicação é compilada a tupla vazia () simplesmente desaparece, então podemos fazer isso.</p>
<pre><code>mod foo {
    pub struct Point {
        pub x: i32,
        pub y: i32,
        _secret: (),
    }
    
    impl Point {
        pub fn new(x: i32, y: i32) -&gt; Point {
            Point { x: x, y: y, _secret: () }
        }
    }
}

fn main() {
    let origin = foo::Point::new(0, 0);
}
</code></pre>
<p>Agora nós temos um novo atributo privado <em>_secret()</em>. Eu dei esse nome com o <em>underscore</em> '_', por que não temos intenção de usa-lo pra nada. Assim o Rust não vai nos dar nenhum warning pois como <em>_secret</em> é do tipo () e será gerado em tempo de compilação e não afetará nosso <em>struct</em> <em>Point</em>.</p>
<p>Mas, tendo este atributo privado afeta a permissão que temos para contruir <em>Point</em>. <em>main</em> não pode usar a sintaxe literal de <em>struct</em> uma vez que nem todos os campos são públicos.</p>
<p>No entanto lembre-se que privacidade é em nível de módulo em Rust, portanto ainda podemos usar a sintaxe literal dentro do módulo <em>foo</em>:</p>
<pre><code>mod foo {
    pub struct Point {
        pub x: i32,
        pub y: i32,
        _secret: (),
    }
    
    impl Point {
        pub fn new(x: i32, y: i32) -&gt; Point {
            Point { x: x, y: y, _secret: () }
        }
    }

    fn foo() -&gt; Point {
        Point: { x: 0, y: 0, _secret: () } // Isto ainda é permitido!
    }
}

fn main() {
    let origin = foo::Point::new(0, 0);
}
</code></pre>
<p>Para previnir que <em>foo</em> seja usado com sintaxe literal, nós precisamos de mais um conceito: <em>pub use</em>, veja isto:</p>
<pre><code>mod foo {
    mod point {
        pub struct Point {
            pub x: i32,
            pub y: i32,
            _secret: (),
        }
    
        impl Point {
            pub fn new(x: i32, y: i32) -&gt; Point {
                Point { x: x, y: y, _secret: () }
            }
        }
    }

    pub use foo::point::Point;

    fn foo() -&gt; Point {
        Point::new(0, 0) // Precisamos usar `new` aqui, Já que não estamos mais dentro do mesmo módulo!
    }
}

fn main() {
    let origin = foo::Point::new(0, 0);
}

</code></pre>
<p>Dando pra <em>Point</em> seu próprio módulo, tudo que é privado pra ele fica privado para quem o usa-lo também. Mas, escrevendo <code>foo::point::Point</code> fica verboso, ai <code>pub use</code> vem nos salvar! Nós re-exportamos a estrutura de <em>Point</em> em <em>foo</em>, então nós podemos ainda usar  <code>foo:Point</code>, mas uma vez que um de seus membros é privado, a sintaxe literal não é permitida.</p>
<p>Para mim, entender coisas como essa é quando eu realmente começo a sentir que estou conhecendo uma linguagem: juntando três ou quatro conceitos díspares para atingir algum objetivo. É quando uma linguagem deixa de ser um monte de partes desconexas e começa a se tornar um todo coeso.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Mudando path do poetry</title><link>https://blog.jonatasoliveira.dev//mudando-path-do-poetry.html</link><description><![CDATA["Como configurar o poetry para mudar o diretório padrão que ele cria a Virtual Env"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//mudando-path-do-poetry.html</guid><pubDate>Wed, 27 Jan 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>Olá tudo bem?</p>
<p>Estou passando aqui pra dar uma dica rápida, quando você possui muitos projetos em python as vezes fica difícil de gerenciar as Virtal Envs do projetos.</p>
<p>Quando usava o pipenv isso não era tanto um problema, pois ele tinha um comando para remover uma virtualenv e recria-la novamente, porém o poetry até esse momento ainda não criou tal comando. Ai lembre do Renzo do <a href="https://www.python.pro.br">Python Pro</a>, falava que criava as envs diretamente no projeto numa pasta .env, então decidi fazer assim também no meu ambiente e vem me ajudando muito.</p>
<p>Pra fazer isso é bem simples é só executar o comando abaixo no seu terminal:</p>
<pre><code>poetry config virtualenvs.in-project true
</code></pre>
<p>Lembrando que pra funcionar você precisa ter o poetry instalado no seu pipenv =D</p>
<p>Bom gente é isso, espero que lhe ajudem.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Afiando o machado 2021</title><link>https://blog.jonatasoliveira.dev//afiando-o-machado-2021.html</link><description><![CDATA["As ferramentas que estou usando no meu workflow de trabalho"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//afiando-o-machado-2021.html</guid><pubDate>Fri, 15 Jan 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h1><a href="#afiando-o-machado-em-2021" aria-hidden="true" class="anchor" id="afiando-o-machado-em-2021"></a>Afiando o machado em 2021</h1>
<p>Bom estamos começando mais um ano, deixando esse difícil ano de 2020 pra trás, então decidi no hiato entre 2020 e 2021 de revisar meu ambiente de desenvolvimento, então gostaria de compartilhar com vocês como está ficando.</p>
<p>Pra começar é bom colocar as linguagens / frameworks que tenho configuradas no meu ambiente :</p>
<ul>
<li>Dart / Flutter</li>
<li>Python / Flask / Django / FastAPI</li>
<li>Javascript / Vue</li>
<li>Rust</li>
<li>Go</li>
</ul>
<p>Um ponto que acho interessante frisar que em 2021 vou ter um ano atípico no que diz a sistema operacional, vou começar o ano com o Mac, lá pelo meio do ano vou usar o Windows e no fim do ano devo voltar pro Linux, mais precisamente o Arch se não viu meu artigo anterior <a href="https://jonatasoliveira.dev/blog/minha-instalacao-do-arch-linux/">acesse aqui</a> ali eu já fiz uma guia da minha instalação.</p>
<p>Com isso meu ambiente de desenvolvimento tem que ser o mais flexível possível, além de tudo eu gosto de trabalhar no terminal então como vou usar o WSL2 no Windows (talvez até um virtualbox mesmo) vai ser mais tranquila essa transição.</p>
<p>Legal já frisar que nesse artigo específico não vou explicar detalhadamente a configuração de cada ferramenta, pretendo fazer isso ao longo do ano, mas já queria falar quais ferramentas estou usando hoje.</p>
<p>Outro ponto importante pra mim é eu gosto de experimentar uma coisa ou outra, mas sempre de forma separada do fluxo padrão, pois eu posso achar que um projeto ainda não está tão legal pra mim, simplesmente desistir ou ainda intrega-lo no meu workflow principal, removendo a ferramenta anterior, faço isso muito por curiosidade sobre o desenvolvimento de outras ferramentas e vez ou outra acabo incorporando uma ferramenta nova durante o ano ou mesmo um plugin. Algo pra entrar no meu workflow precisa me deixar mais produtivo e não o contrário.</p>
<p>Pra facilitar a sua leitura deu dividi o artigo nos tópicos abaixo:</p>
<ul>
<li>Fontes</li>
<li>Prompt de comando</li>
<li>Emulador de terminal</li>
<li>Multiplexador</li>
<li>Python</li>
<li>Dart / Flutter</li>
<li>Vue</li>
<li>Editor</li>
<li>Docker</li>
<li>Conclusão</li>
</ul>
<h2><a href="#fontes" aria-hidden="true" class="anchor" id="fontes"></a>Fontes</h2>
<p>Uma coisa que pode não parecer muito importante, mas que no meu workflow eu acho super importante é o uso do <a href="https://www.nerdfonts.com/">nerdfonts</a>, pois ele me dá um conjunto de fontes e ícones que vou colocar tanto no meu terminal, quanto no meu editor de texto, como eu fico 80% do meu tempo dentro do terminal ter boas fontes e bons ícones ajuda a deixar o ambiente mais agradável, sei que muita gente gosta e vive bem com um terminal mais &quot;seco&quot; e vive bem com isso.</p>
<p>Além disso, eu pretendo usar também os ícones e fontes no próprio Xmonad.</p>
<h2><a href="#tema" aria-hidden="true" class="anchor" id="tema"></a>Tema</h2>
<p>Um tema que venho usando e gosto muito é o <a href="https://draculatheme.com/">dracula</a>, o bom dele é que basicamente posso usar o mesmo esquema de cores em todas as ferramentas que uso, inclusive no meu browser, então tudo que eu posso eu tento usar o drácula como tema.</p>
<p>No caso do Xmonad ainda não tem um tema, mas pretendo resolver essa pendência =D.</p>
<h2><a href="#prompt-de-comando" aria-hidden="true" class="anchor" id="prompt-de-comando"></a>Prompt de comando</h2>
<p>Aqui eu uso o <a href="https://www.zsh.org/">zsh</a> como shell, para complementar uso o <a href="https://ohmyz.sh/">ohmyzsh</a> pois ele me trás vários plugins úteis para o dia-a-dia e o <a href="https://starship.rs/">starship</a> para customizar a visualização do prompt pois ele possui várias opções de customizar a visualização e acho ele infinitamente mais leve que o tema do <a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a> que me dá várias opções mas, pelo menos no mac hoje fica bem pesado quando uso.</p>
<p>Com isso já consigo usar autocomplete e ter alguns indícios visuais de um repositório, e no meu .zshrc eu vou colocando as configurações e alias de comando que mais uso no dia-a-dia.</p>
<p>Uma coisa que penso em experimentar durante o ano é o <a href="https://fishshell.com/">fish shell</a> e o <a href="https://elv.sh/learn/">elvish shell</a>.</p>
<h2><a href="#emulador-de-terminal" aria-hidden="true" class="anchor" id="emulador-de-terminal"></a>Emulador de terminal</h2>
<p>Pode não parecer, mas minha ideia é ter o menor número de ferramentas / plugins dentro do meu workflow, pois é fácil você configurar algo e raramente usar. Porém no caso do emulador de terminal ainda tenho um dilema estou usando 2, o <a href="https://github.com/alacritty/alacritty">alacritty</a> e o <a href="https://sw.kovidgoyal.net/kitty/">kitty</a>.</p>
<p>O <a href="https://github.com/alacritty/alacritty">alacritty</a> é um emulador de terminal pequeno, leve e poderoso, ele segue o conceito dos emuladores com poucas features, o que é perfeito pra usar em tilling manager como o Xmonad ou o i3, porém hoje ele não tem uma feature que estou usando no momento, que é a compatibilidade para fontes com ligadura, tipo o fira code.</p>
<p>Por conta disso estou usando o <a href="https://sw.kovidgoyal.net/kitty/">kitty</a>, que é um emulador de terminal com muitos recursos, porém fora suas configurações básicas, não uso as features tmux like dele, muito por que acho que o próprio alacritty no futuro vai ter essa feature e eu devo voltar pra ele, e não me entenda mal o kitty é ótimo, mas muitas das features dele eu já resolvo com tmux + Xmonad, o que pode parecer estranho já que quero ter sempre o mínimo possível de ferramentas, mas durante esse ano se em algum momento eu achar que o Kitty está sendo mais vantajoso com certeza vou permanecer nele.</p>
<p>Mas por enquanto a ideia é ter o alacritty como emulador de terminal principal.</p>
<h2><a href="#multiplexador" aria-hidden="true" class="anchor" id="multiplexador"></a>Multiplexador</h2>
<p>Aqui só tem uma ferramenta que uso que é o <a href="https://github.com/tmux/tmux">tmux</a>, ele nada mais é que um multiplexador, trabalha com abas além de manipular as janelas de maneira muito parecida com o tilling manager, mas então por que usar isso até pelo que falei sobre o kitty?</p>
<p>Uso principalmente por conta de gerar uma sessão e uma sessão básica, e o que isso quer dizer? Primeiro quando crio uma sessão no tmux, mesmo que feche o terminal a sessão ainda vai ficar de pé até que você reinicie o computador ou mate a sessão. Assim mesmo que acidentalmente feche o terminal a minha sessão vai continuar em pé normalmente.</p>
<p>Agora outra feature que o tmux tem é poder criar templates de sessões, ou seja, já posso configurar quantidade de janelas, diretório que vai abrir além de dar start em alguma ferramenta como um git fetch ou coisa do tipo. Hoje uso apenas uma sessão e abro tudo que eu possa precisar, isso até por que hoje estou usando o mac e é mais conveniente abrir tudo já, porém quando voltar a usar o linux penso em criar sessões especializadas (editor, kubernetes, dart e etc), pois ao invés de ficar trabalhando com várias abas no tmux, posso trabalhar com uma apenas mas, com o workflow da atividade que vou trabalhar já.</p>
<p>Voltando ao kitty ele faz isso também tanto em manter sessão quanto montar templates de uso, aqui a preferência é por já ter o costumo com os atalhos do tmux, conforme esse ano for passando talvez eu faça alguns testes usando só o kitty, por que talvez eu ganhe mais usando só ele ao invés do alacritty + tmux.</p>
<h2><a href="#python" aria-hidden="true" class="anchor" id="python"></a>Python</h2>
<p>Aqui nessa sessão eu configuro a versão do python e meu ambiente virtuais, primeira ferramenta que uso é o <a href="https://github.com/pyenv/pyenv">pyenv</a>, no caso ele vai gerenciar a versão do python que estou usando em determinado projeto, por exemplo, hoje tenho projetos que usam python 3.5, 3.7 e 3.9, isso muito por que alguns projetos usam bibliotecas de terceiros que são incompatíveis com versões mais recentes do python.</p>
<p>Além disso o pyenv me dá a possibildade de não &quot;sujar&quot; a versão do python do sistema (mac/linux), pois essa versão vai ser usada para as aplicações do sistema, e prefiro deixar ela intocada, isso é interessante se você algum dia já instalou várias bibliotecas no seu python de sistema e um aplicativo já parou de funcionar por conflito, tendo a versão do python segregada te ajuda a resolver esse problema, além disso o pyenv você consegue configurar na sua versão global todas as versões que vc está usando.</p>
<p>O pyenv tem plugins para gerenciar suas virtuals envs, porém hoje eu prefiro usar o <a href="https://python-poetry.org/">poetry</a>, ele ajudar a manter o controle das bibliotecas que uso em determinado projeto, mantém uma árvore de dependências, versionando inclusive lib dependentes do meu projeto além de criar minha virtualenv tudo com um comando, e isso é uma das coisas que mais gosto dele.</p>
<h2><a href="#dart--flutter" aria-hidden="true" class="anchor" id="dart--flutter"></a>Dart / Flutter</h2>
<p>Aqui não tem muito segredo, pois eu simplesmente uso o procedimento do site do <a href="https://flutter.dev/docs/get-started/install">flutter</a> pra fazer a instalação, como não mexo tanto no dart/flutter (esse ano devo usar mais), então a configuração padrão já me atende sem muito problema.</p>
<p>Aqui talvez num futuro se precisar trabalhar com versões diferentes do dart uma solução seria usar o [asdf] (<a href="https://github.com/asdf-vm/asdf">https://github.com/asdf-vm/asdf</a>), mas ainda não sei se seria necessário.</p>
<h2><a href="#vue" aria-hidden="true" class="anchor" id="vue"></a>Vue</h2>
<p>Para trabalhar com vue eu preciso de duas coisas, primeiro o <a href="https://github.com/nvm-sh/nvm">NVM</a> com ele eu consigo usar a versão do Node que eu quiser para determinado projeto de forma fácil e rápida, é um processo bem parecido com o pyenv, a segunda coisa que preciso é o <a href="https://cli.vuejs.org/">VueCLI</a> que já ajuda a criar os projetos VUE de forma bem rápida, além de subir um plugins pré configurados.</p>
<h2><a href="#editor" aria-hidden="true" class="anchor" id="editor"></a>Editor</h2>
<p>Já usei vários editores na vida, mas nos últimos anos tenho dado preferência ao vim e mais especificamente ao <a href="https://neovim.io/">NeoVim</a>, muito por que mesmo tendo vários plugins nele ainda é bem leve para se trabalhar.</p>
<p>O NeoVim quando instalado já possui várias configurações interessantes, das quais pretendo colocar em outro post que já ajuda bastante, mas gostaria de falar aqui dos principais plugins que uso hoje.</p>
<p>Para ter um intellisense e alguns auto formats eu uso o <a href="https://github.com/neoclide/coc.nvim">COC</a> ele já me da uma gama de possibilidades de configurar o interpretador para python, js, vue e dart e sem muito esforço, sua única inconveniência ao meu ver é ter que criar uma pasta de configuração .vim em todos os projetos que trabalho. Com ajuda do COC eu também configuro a parte do <a href="https://github.com/universal-ctags/ctags">cTags</a> para poder funcionar os Go To na navegação do código.</p>
<p><a href="https://github.com/preservim/nerdtree">NerdTree</a> eu uso para poder navegar nos diretórios do projeto e poder alterar, adicionar e remover pastas e diretórios é bem fácil de usar e bem funcional.</p>
<p><a href="https://github.com/junegunn/fzf.vim">FZF</a>, <a href="https://github.com/kien/ctrlp.vim">CTRLP</a> e o <a href="https://github.com/wincent/ferret">FERRET</a>, são um conjunto de plugins para fazer busca tanto no diretório quanto detro dos arquivos junto com o <a href="https://github.com/BurntSushi/ripgrep">RG</a> e o <a href="https://github.com/ggreer/the_silver_searcher">AG</a> para aplicar os algoritmos de busca o que otimiza o tempo para fazer as buscas. Com isso já consigo fazer buscas rápidas pelo meu código.</p>
<p><a href="https://github.com/tpope/vim-fugitive">VIM-FUGITIVE</a> pra mim um dos melhores plugins para dominar no vim, com ele eu consigo trabalhar e ir fazendo meus commits, pulls, pushs sem precisar ter uma outra janela do terminal pra ficar fazendo isso, o que acaba facilitando muito a vida, além de conseguir fazer um gitdiff quando em pull acontece algum conflito com minhas alterações.</p>
<p>Bom poderia falar de muitos outros plugins que uso mas, acredito que hoje esses são os mais essenciais pro meu dia-a-dia de trabalho.</p>
<h2><a href="#docker" aria-hidden="true" class="anchor" id="docker"></a>Docker</h2>
<p>Aqui também uso as instalações padrões do <a href="https://docs.docker.com/get-docker/">docker</a> e <a href="https://docs.docker.com/compose/install/">docker-compose</a>, além de muitas vezes ainda não desenvolver diretamente no docker, todas as estruturas de apoio para o desenvolvimento como db, filas, ferramentas de monitoração e etc, eu rodo no docker, e também quando preciso simular algum problema que não ocorre quando subo o projeto diretamente no poetry eu acabo apelando pra subir o projeto via docker-compose e ver se consigo replicar o erro.</p>
<p>Penso que quando você começa a trabalhar com docker, você vai sentir dificuldade de deixar ele, pois ele ajuda muito a deixar as configs do seu sistema limpas, pois todas as bibliotecas, instalações e afins estão contidas dentro do container.</p>
<h2><a href="#conclusão" aria-hidden="true" class="anchor" id="conclusão"></a>Conclusão</h2>
<p>A ideia aqui foi apresentar o conjunto de ferramentas que uso no meu workflow de trabalho no dia-a-dia, aqui além de talvez você me falar que instalando o pacote do jetbrains eu teria quase tudo isso já na mão.</p>
<p>Mas, como sempre digo a melhor ferramenta é a que você se sente mais produtivo, acredito que o meu workflow tem uma produtividade bem alta e com um baixo custo de recursos (vendo que tenho um mac de 2014 e um notebook que é um core 2 duo com 4gb de ram), além disso ter um workflow via terminal é extremamente poderoso pois faço praticamente tudo que preciso apenas usando alguns comandos ou atalhos no teclado. Acredito que no caso de um workflow como o meu tem um grande trabalho em &quot;esculpir&quot; as configurações, porém ele fica exatamente do jeito que você quer ao contrário de um jetbrains ou mesmo o vscode que você acaba ficando preso a algumas definições da ferramenta.</p>
<p>Enfim, espero que você goste e convido a compartilhar ferramentas que você ache legal pra trabalhar num workflow usando terminal ou algum outro workflow que você use, gosto muito de conhecer outros workflows de trabalho =).</p>
<p>Então é isso e até o próximo artigo.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Minha instalação do Arch Linux</title><link>https://blog.jonatasoliveira.dev//minha-instalac-a-o-do-arch-linux.html</link><description><![CDATA["Um roteiro de como eu instalo o Arch Linux"]]></description><author>Jônatas Luiz de Oliveira</author><guid>https://blog.jonatasoliveira.dev//minha-instalac-a-o-do-arch-linux.html</guid><pubDate>Fri, 08 Jan 2021 00:00:00 GMT</pubDate><source url="https://blog.jonatasoliveira.dev/">archive-2021</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h1><a href="#instalação-do-arch-linux" aria-hidden="true" class="anchor" id="instalação-do-arch-linux"></a>Instalação do Arch Linux</h1>
<p>Bom começando 2021 com um blog novo decidi compartilhar o meu roteiro para instalar o Arch Linux com algumas explicações.</p>
<p>No longínquo ano de 2004 eu brincava com instalações complicadas como o FreeBSD, Gentoo e o Slackware, foi uma boa base para aprender muito, com todos os kernel panics  da vida,
mas minha vida com o pinguim naquela época ainda era só uma curiosidade, pois trabalhava com Delphi e ambiente Windows além de que nessa época era bem complicado jogar no Linux.</p>
<p>Desde de 2014 voltei a trabalhar usando Linux inicialmente como freelance e depois na minha ocupação principal, um pouco isso se deve ao trabalho do Dionatan do <a href="https://diolinux.com.br/">Diolinux</a>, mas desde então conhecim uma distro que não havia conhecido lá no começo dos anos 2000 que era o Arch linux, gostei muito da ideia do Pacman que é muito parecido com o Brew do MacOs, mas mesmo assim sempre fiquei nas distros ubuntu like pois era um sistema que eu tinha mais familiaridade.</p>
<p>Esse ano de 2021 vai ser um ano atipico pra mim eu nesse momento estou usando um Mac, mas no meio do ano vou trabalhar alguns meses numa estação Windows até que mais pro final do
ano estou pensando em pegar um notebook da <a href="https://system76.com/">System76</a>, então no perído entre festas ali de 2020 eu decidi me aventurar em fazer uma instalação do Arch numa
virtualbox para ter um roteiro pronto pra usar no meio do ano pra voltar a usar o Arch.</p>
<p>Um ponto importante é que lá por 2017 eu comecei a usar o xubuntu com o gerenciador de janelas i3, antes de começar a usar o mac estava usando o <a href="https://xmonad.org/">Xmonad</a> nesse guia eu levo em consideração a instalação do Xmonad pois já tenho meus arquivos de configuração que basicamente devo copiar, caso tenha interesse você pode ver no meu <a href="https://github.com/jonatasoli/dotfiles">GitHub</a>.</p>
<p>Um disclamer antes do guia, na verdade eu achei a configuração do Arch relativamente tranquila, a <a href="https://wiki.archlinux.org/index.php/installation_guide">documentação oficial</a>,
além de que pra mim me enrolei em alguns pontos que não estão muitos explicitos ali, então por isso fiz esse guia, dois vídeos que me ajudaram muito foi esse do <a href="https://www.youtube.com/watch?v=4orYC5ARfn8&amp;t=3212s">Diolinux</a> e essa do <a href="https://www.youtube.com/watch?v=PQgyW10xD8s&amp;t=1340s">Derek Taylor</a>, que alias também tem materiais muitos bons.</p>
<h2><a href="#verificando-uefi-mode" aria-hidden="true" class="anchor" id="verificando-uefi-mode"></a>Verificando UEFI Mode</h2>
<ul>
<li>Verificar o bootmode se o comando abaixo der erro é por que está no UEFI mode
Pode ser que essa pasta não exista ai o computador não tem suporte a UEFI</li>
</ul>
<pre><code>ls /sys/firmware/efi/efivars
</code></pre>
<h2><a href="#gerando-o-particionamento" aria-hidden="true" class="anchor" id="gerando-o-particionamento"></a>Gerando o particionamento</h2>
<p>Aqui acredito que é algo bem pessoal, cada um organiza do jeito que acha melhor eu particularmente uso um / /boot /home /swap usando uma estrutura de partições GPT, caso você não
saiba o que é de uma olhada <a href="https://sempreupdate.com.br/quais-as-diferencas-entre-gpt-guid-e-mbr/">nesse artigo do sempreupdate</a>.</p>
<ul>
<li>Particionar o disco</li>
</ul>
<pre><code>fdisk -l #lista discos
fdisk /dev/sda # ou o disco que vc quer particionar
exemplo de criação com comandos para o /boot
- n
- 1
- 2048
- +200M

# Pra criar uma partição existente como swap
- t
- 2 # numero da partição
- 19 # Código do swap

# Bootloader
- t
- 1
- 1 # EFI Filesystem ou 4 bios boot se for MBR
</code></pre>
<p>Agora precisamos formatar as partições pra isso usamos o <code>mkfs</code> e no caso do swap usamos o <code>mkwap e swapon</code>.</p>
<ul>
<li>Formatar partições</li>
</ul>
<pre><code>mkfs.ext4 /dev/sda1

# Swap
mkswap /dev/sda2
swapon /dev/sda2
</code></pre>
<ul>
<li>Instalar dostools</li>
</ul>
<pre><code>pacman -S dosfstools
</code></pre>
<ul>
<li>Formatar a partição do boot</li>
</ul>
<pre><code>mkfs.fat -F 32 /dev/sda1
# Pode ser BIOS boot ou EFI que é a opção 1
</code></pre>
<h2><a href="#montando-os-filesystems" aria-hidden="true" class="anchor" id="montando-os-filesystems"></a>Montando os filesystems</h2>
<p>Bom o próximo passo é montar o filesystem para fazer a instalação além de montar os diretórios que vão ficar separados em partições diferentes como o /boot e o /home. Acho bom
enfatizar que o nome das partições vai variar dependendo de como você particionou, no meu caso vai ser /dev/sda1 /dev/sda2 /dev/sda3 e /dev/sda4, porém abaixo deixei da forma mais
genérica.</p>
<ul>
<li>Montar o filesystem</li>
</ul>
<pre><code>mount /dev/root_partition /mnt
</code></pre>
<ul>
<li>Criar pastas de boot e home</li>
</ul>
<pre><code>mkdir /mnt/home
mkdir /mnt/boot/ # caso EFI tem que ser /mnt/boot/EFI
</code></pre>
<ul>
<li>Montar o filesystem</li>
</ul>
<pre><code>mount /dev/mount-boot /mnt/boot
mount /dev/mount-home /mnt/home
</code></pre>
<h2><a href="#instalação" aria-hidden="true" class="anchor" id="instalação"></a>Instalação</h2>
<p>Bom agora chegou a hora da instalação, como você vai ver é bem simples:</p>
<ul>
<li>instalar os pacotes básicos</li>
</ul>
<pre><code>pacstrap /mnt base base-devel linux linux-firmware
</code></pre>
<p>Agora vamos gerar o fstab, se não sabe o que é o fstab da uma conferida nesse <a href="https://www.youtube.com/watch?v=C63VJV3sOos">vídeo do Diolinux</a>.</p>
<ul>
<li>Gerar o fstab</li>
</ul>
<pre><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>
<p>Agora vamos montar o root do arch linux.</p>
<ul>
<li>Mudar a montagem pra root</li>
</ul>
<pre><code>arch-chroot /mnt
</code></pre>
<ul>
<li>Setar hora local</li>
</ul>
<pre><code>ln -sf /usr/share/zoneinfo/America/Sao_Paulo /etc/localtime
hwclock --systohc
</code></pre>
<ul>
<li>Instalar o neovim ou editor da sua preferência.</li>
</ul>
<pre><code>pacman -Sy neovim
</code></pre>
<ul>
<li>Editar o arquivo /etc/locale.gen e descomentar o en-UTF8 ou a lingua que você usa como pt_BR-UTF8</li>
</ul>
<pre><code># depois gerar os arquivos
locale-gen
</code></pre>
<ul>
<li>Criar arquivo /etc/locale.conf e add a linguagem padrão do sistema</li>
</ul>
<pre><code>LANG=en_US.UTF-8
</code></pre>
<h2><a href="#hostname" aria-hidden="true" class="anchor" id="hostname"></a>Hostname</h2>
<ul>
<li>
<p>Add o hostname em /etc/hostname</p>
</li>
<li>
<p>Editar o /etc/hosts</p>
</li>
</ul>
<pre><code>/etc/hosts

127.0.0.1	localhost
::1		localhost
127.0.1.1	myhostname.localdomain	myhostname
</code></pre>
<h2><a href="#gestão-do-user" aria-hidden="true" class="anchor" id="gestão-do-user"></a>Gestão do USER</h2>
<ul>
<li>Definir senha do root</li>
</ul>
<pre><code>passwd
</code></pre>
<ul>
<li>Add user</li>
</ul>
<pre><code>useradd -m -g users -G wheel,audio,video,storage nome_desejado_para_o_usuario
</code></pre>
<ul>
<li>Add no /etc/sudoers</li>
</ul>
<pre><code>myuser ALL=(ALL) ALL
</code></pre>
<p>Atualizar agora o usuário que eu criei com o passwd.</p>
<pre><code>passwd nome_desejado_para_o_usuario
</code></pre>
<h2><a href="#pacotes-adicionais" aria-hidden="true" class="anchor" id="pacotes-adicionais"></a>Pacotes adicionais</h2>
<ul>
<li>Instalar pacotes adicionais (pra wifi continuar funcionando no pos instalação)</li>
</ul>
<pre><code>pacman -S dosfstools os-prober mtools network-manager-applet networkmanager wpa_supplicant wireless_tools dialog sudo
</code></pre>
<h2><a href="#grub" aria-hidden="true" class="anchor" id="grub"></a>Grub</h2>
<p>Acho que foi a parte que mais me enrosquei, importante que precisa já ter criado e formatado, além disso aqui é importante que ele usa pacotes diferentes dependendo do tipo da sua
partição do boot.</p>
<ul>
<li>Instalar o GRUB</li>
</ul>
<pre><code>pacman -S grub os-prober

# MBR

grub-install --target=i386-pc --recheck /dev/sda

# EFI
pacman -S efibootmgr
grub-install --target=x86_64-efi --bootloader-id=grub_uefi --recheck

CONFIG
grub-mkconfig -o /boot/grub/grub.cfg

</code></pre>
<h2><a href="#pós-instalação" aria-hidden="true" class="anchor" id="pós-instalação"></a>Pós Instalação</h2>
<p>Primeiro vou habilitar o networkmanager pois senão não vai habilitar a rede.</p>
<ul>
<li>Hábilitar o network manager</li>
</ul>
<pre><code>systemctl enable NetworkManager
</code></pre>
<p>Depois disso reinicio e testo através de um ping se está funcionando a rede além é claro de logar com o meu usuário, agora pra usar o pacman vamos usar o sudo.</p>
<ul>
<li>Instalar o básico pra usar o Xmonad e algumas aplicações</li>
</ul>
<pre><code>sudo pacman -Syy xorg xorg-xinit xf86-video-fbdev(ou sua placa de video) nitrogen picom firefox neovim ranger rxvt-unicode
sudo pacman -Syy lightdm lightdm-gtk-greeter xmonad xmonad-contrib xmobar dmenu kitty
</code></pre>
<p>Ali instalo dois terminais o urxvt e o kitty, isso acontece pois quando fiz a instalação tive problemas com o kitty no inicio da configuração, então uso o urxvt e depois de copiar
todas as minhas configs eu mudo para o kitty, já que o caração de usar um tilling manager é ter acesso fácil ao terminal.</p>
<ul>
<li>Configurar o .xinitrc copiando o exemplo do xorg pra sua home</li>
</ul>
<pre><code>cp /etc/X11/xinit/xinitrc .xinitrc
</code></pre>
<ul>
<li>Adicionar o arquivo o start do nitrogen do picom e do xmonad</li>
</ul>
<pre><code># Remover
twm &amp;
...
exec xterm -geometry 80x66+0+0 -name login

#Adicionar
exec xmonad
</code></pre>
<p>Bom com essa configuração eu já consigo iniciar o Xmonad, eu gosto de deixar ele funcional já por que se houver algum problema pra subir o Xorg ou o Xmonad ele ainda vai entrar em
modo texto.</p>
<ul>
<li>Testar a inicialização</li>
</ul>
<pre><code>startx
</code></pre>
<p>Bom agora aqui eu copio meus arquivos de configuração, se você não tem os seus pode usar o meu <a href="https://github.com/jonatasoli/dotfiles">clicando aqui</a>.</p>
<ul>
<li>Copiar os arquivos de configuração do xmonad e do xmobar</li>
</ul>
<pre><code># criar diretório .xmonad
# criar diretório .config/xmobar

Normalmente eu reinicio logo novamente e dou um startx só pra ter certeza que tudo está funcionando, ai sim eu habilito o lightdm pra iniciar tudo já no modo gráfico.
</code></pre>
<ul>
<li>Habilitar o lightdm</li>
</ul>
<pre><code>sudo systemctl enable lightdm
</code></pre>
<p>Depois disso, eu começo a configurar o meu ambiente de desenvolvimento mas, o sistema já está pronto pra ser usado. Caso tenham alguma dúvida pode colocar nos comentários que ajudo
da melhor maneira que conseguir.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item></channel></rss>